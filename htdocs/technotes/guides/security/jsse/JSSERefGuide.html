<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<!-- *********************************** -->
<head>
<title>JSSE Reference Guide</title>
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Java Secure Socket Extension (JSSE) Reference Guide</h1>
<ul>
<li><a href="#Introduction">Introduction</a>
<ul>
<li><a href="#Features">Features and Benefits</a></li>
<li><a href="#StandardAPI">JSSE Standard API</a></li>
<li><a href="#SunJSSE">SunJSSE Provider</a></li>
<li><a href="#RelatedDocs">Related Documentation</a></li>
</ul>
</li>
<li><a href="#Terms">Terms and Definitions</a></li>
<li><a href="#tls-protocol-overview">Transport Layer Security (TLS) Protocol Overview</a></li>

<li><a href="#JSSEClasses">JSSE Classes and Interfaces</a>
<ul>
<li><a href="#CoreClasses">Core Classes and Interfaces</a>
<ul>
<li><a href="#SocketFactory">SocketFactory and ServerSocketFactory
Classes</a></li>
<li><a href="#SSLSocketFactory">SSLSocketFactory and
SSLServerSocketFactory Classes</a></li>
<li><a href="#SSLSocket">SSLSocket and SSLServerSocket
Classes</a></li>
<li><a href="#SSLEngine">SSLEngine Class</a></li>
<li><a href="#SSLSession">SSLSession and ExtendedSSLSession Interfaces</a></li>
<li><a href="#HttpsURLConnection">HttpsURLConnection Class</a></li>
</ul>
</li>
<li><a href="#SupportClasses">Support Classes and Interfaces</a>
<ul>
<li><a href="#SSLContext">SSLContext Class</a></li>
<li><a href="#TrustManager">TrustManager Interface</a></li>
<li><a href="#TrustManagerFactory">TrustManagerFactory
Class</a></li>
<li><a href="#X509TrustManager">X509TrustManager Interface</a></li>
<li><a href="#X509ExtendedTrustManager">X509ExtendedTrustManager
Class</a></li>
<li><a href="#KeyManager">KeyManager Interface</a></li>
<li><a href="#KeyManagerFactory">KeyManagerFactory Class</a></li>
<li><a href="#X509KeyManager">X509KeyManager Interface</a></li>
<li><a href="#X509ExtendedKeyManager">X509ExtendedKeyManager
Class</a></li>
<li><a href="#RelsTM_KM">Relationship Between a TrustManager and a
KeyManager</a></li>
</ul>
</li>
<li><a href="#SecondarySupportClasses">Secondary Support Classes
and Interfaces</a>
<ul>
<li><a href="#SSLParameters">SSLParameters Class</a>
<ul>
<li><a href="#cipher_suite_preference">Cipher Suite
Preference</a></li>
</ul>
</li>
<li><a href="#SSLSessionContext">SSLSessionContext
Interface</a></li>
<li><a href="#SSLSessionBindingListener">SSLSessionBindingListener
Interface</a></li>
<li><a href="#SSLSessionBindingEvent">SSLSessionBindingEvent
Class</a></li>
<li><a href=
"#HandShakeCompletedListener">HandShakeCompletedListener
Interface</a></li>
<li><a href="#HandShakeCompletedEvent">HandShakeCompletedEvent
Class</a></li>
<li><a href="#HostnameVerifier">HostnameVerifier Interface</a></li>
<li><a href="#X509Certificate">X509Certificate Class</a></li>
<li><a href="#AlgorithmConstraints">AlgorithmConstraints
Interface</a></li>
<li><a href="#StandardConstants">StandardConstants Class</a></li>
<li><a href="#SNIServerName">SNIServerName Class</a></li>
<li><a href="#SNIMatcher">SNIMatcher Class</a></li>
<li><a href="#SNIHostName">SNIHostName Class</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#InstallationAndCustomization">Customizing JSSE</a>

<ul>
<li><a href="#SecurityProps">How to Specify a java.security.Security Property</a></li>
<li><a href="#how-to-specify-a-java-lang-system-property">How to Specify a java.lang.System Property</a></li>
<li><a href="#enabling-tls-1.3">Enabling TLS 1.3</a></li>
<li><a href="#X509CCust">Customizing the X509Certificate Implementation</a></li>
<li><a href="#default-enabled-cipher-suites">Specifying Default Enabled Cipher Suites</a></li>
<li><a href="#HTTPSCust">Specifying an Alternative HTTPS Protocol Implementation</a></li>
<li><a href="#ProviderCust">Customizing the Provider Implementation</a></li>
<li><a href="#registering-the-cryptographic-service-provider-statically">Registering the Cryptographic Service Provider Statically</a></li>
<li><a href="#registering-the-cryptographic-service-provider-dynamically">Registering the Cryptographic Service Provider Dynamically</a></li>
<li><a href="#CustomizingStores">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></li>
<li><a href="#DefaultKTMCust">Customizing the Default Key Managers and Trust Managers</a></li>
<li><a href="#DisabledAlgorithms">Disabled and Restricted Cryptographic Algorithms</a></li>
<li><a href="#LegacyAlgorithms">Legacy Cryptographic Algorithms</a></li>
<li><a href="#JCECust">Customizing the Encryption Algorithm Providers</a></li>
<li><a href="#customizing_dh_keys">Customizing the Size of Ephemeral Diffie-Hellman Keys</a></li>
<li><a href="#mfln-extension">Customizing Maximum Fragment Length Negotiation (MFLN) Extension</a></li>
<li><a href="#limit-data-encrypted">Limiting Amount of Data Algorithms May Encrypt with a Set of Keys</a></li>
<li><a href="#acknowledge-close-notify-alert">Specifying That close_notify Alert Is Sent When One Is Received</a></li>
<li><a href="#ConfiguringDefaultExtensions">Configuring Default Extensions</a></li>
</ul>

</li>

<li><a href="#ocsp">Determine X.509 Certificate Revocation Status with OCSP</a></li>

<li><a href="#PKCS11">Hardware Acceleration and Smartcard
Support</a>
<ul>
<li><a href="#ConfigSmartcard">Configuring JSSE to Use Smartcards
as Keystores and Truststores</a></li>
<li><a href="#MultiDynamicKeystores">Multiple and Dynamic
Keystores</a></li>
</ul>
</li>
<li><a href="#KRB">Kerberos Cipher Suites</a>
<ul>
<li><a href="#KRBRequire">Kerberos Requirements</a></li>
<li><a href="#KRBPeerID">Peer Identity Information</a></li>
<li><a href="#KRBSM">Security Manager</a></li>
</ul>
</li>
<li><a href="#KeystoreFormats">Additional Keystore Formats
(PKCS12)</a></li>
<li><a href="#SNIExtension">Server Name Indication (SNI)
Extension</a></li>
<li><a href="#ALPN">TLS Application Layer Protocol Negotiation </a></li>
<li><a href="#Troubleshooting">Troubleshooting</a>
<ul>
<li><a href="#InstallProbs">Configuration Problems</a></li>
<li><a href="#Debug">Debugging Utilities</a></li>
</ul>
</li>
<li><a href="#CodeExamples">Code Examples</a>
<ul>
<li><a href="#UnsecureSecure">Converting an Unsecure Socket to a
Secure Socket</a></li>
<li><a href="#SampleCode">Running the JSSE Sample Code</a></li>
<li><a href="#CreateKeystore">Creating a Keystore to Use with
JSSE</a></li>
<li><a href="#SNIExamples">Using the Server Name Indication (SNI)
Extension</a></li>
</ul>
</li>
<li><a href="#AppA">Appendix A: Standard Names</a></li>
<li><a href="#PLUG">Appendix B: Provider Pluggability</a></li>
<li><a href="#tls-renegotiation-issue">Appendix C: TLS Renegotiation Issue</a></li>
<li><a href="#signature-schemes">Appendix D: Signature Schemes</a></li>
</ul>
<hr width="100%" />
<a name="maincontent" id="maincontent"></a> 
<!-- *********************************************** -->
<h2><a name="Introduction" id="Introduction">Introduction</a></h2>
<p>Data that travels across a network can easily be accessed by
someone who is not the intended recipient. When the data includes
private information, such as passwords and credit card numbers,
steps must be taken to make the data unintelligible to unauthorized
parties. It is also important to ensure that the data has not been
modified, either intentionally or unintentionally, during
transport. The Secure Sockets Layer (SSL) and Transport Layer
Security (TLS) protocols were designed to help protect the privacy
and integrity of data while it is being transferred across a
network.</p>
<p>The Java Secure Socket Extension (JSSE) enables secure Internet
communications. It provides a framework and an implementation for a
Java version of the SSL and TLS protocols and includes
functionality for data encryption, server authentication, message
integrity, and optional client authentication. Using JSSE,
developers can provide for the secure passage of data between a
client and a server running any application protocol (such as HTTP,
Telnet, or FTP) over TCP/IP. For an introduction to TLS, see
<a href="tls.html">Transport Layer Security (TLS) Protocol Overview</a>.</p>
<p>By abstracting the complex underlying security algorithms and
handshaking mechanisms, JSSE minimizes the risk of creating subtle
but dangerous security vulnerabilities. Furthermore, it simplifies
application development by serving as a building block that
developers can integrate directly into their applications.</p>
<p>JSSE provides both an application programming interface (API)
framework and an implementation of that API. The JSSE API
supplements the core network and cryptographic services defined by
the <code>java.security</code> and <code>java.net</code> packages
by providing extended networking socket classes, trust managers,
key managers, SSL contexts, and a socket factory framework for
encapsulating socket creation behavior. Because the
<code>SSLSocket</code> class is based on a blocking I/O model, the
Java Development Kit (JDK) includes a nonblocking
<code>SSLEngine</code> class to enable implementations to choose
their own I/O methods.</p>

<p>The JSSE API supports the following security protocols:</p>
<ul>

<li>TLS: version 1.0, 1.1, 1.2, and 1.3 (since JDK 8u261)</li>
<li>SSL (Secure Socket Layer): version 3.0</li>
</ul>
<p>These security protocols encapsulate a normal bidirectional stream socket, and the JSSE API adds transparent support for authentication, encryption, and integrity protection.</p>

<p>JSSE is a security component of the Java SE platform, and is
based on the same design principles found elsewhere in the <a href=
"../crypto/CryptoSpec.html#Design">Java Cryptography Architecture
(JCA)</a> framework. This framework for cryptography-related
security components allows them to have implementation independence
and, whenever possible, algorithm independence. JSSE uses the
<a href="../crypto/CryptoSpec.html#ProviderArch">cryptographic
service providers</a> defined by the JCA framework.</p>
<p>Other security components in the Java SE platform include the
<a href="../jaas/JAASRefGuide.html">Java Authentication and
Authorization Service (JAAS)</a> and the <a href=
"../../../tools/index.html#security">Java Security Tools</a>. JSSE
encompasses many of the same concepts and algorithms as those in
JCA but automatically applies them underneath a simple stream
socket API.</p>
<p>The JSSE API was designed to allow other SSL/TLS protocol and
Public Key Infrastructure (PKI) implementations to be plugged in
seamlessly. Developers can also provide alternative logic to
determine if remote hosts should be trusted or what authentication
key material should be sent to a remote host.</p>
<!-- *********************************************** -->
<h3><a name="Features" id="Features">Features and Benefits</a></h3>
<p>JSSE includes the following important features:</p>
<ul>
<li>Included as a standard component of the JDK</li>
<li>Extensible, provider-based architecture</li>
<li>Implemented in 100% pure Java</li>
<li>Provides API support for TLS</li>
<li>Provides implementations of SSL 3.0 and TLS versions 1.0, 1.1, 1.2, and 1.3 (since JDK 8u261)</li>
<li>Includes classes that can be instantiated to create secure
channels (<code>SSLSocket</code>, <code>SSLServerSocket</code>, and
<code>SSLEngine</code>)</li>
<li>Provides support for cipher suite negotiation, which is part of
the SSL handshaking used to initiate or verify secure
communications</li>
<li>Provides support for client and server authentication, which is
part of the normal SSL handshaking</li>
<li>Provides support for HTTP encapsulated in the SSL protocol,
which allows access to data such as web pages using HTTPS</li>
<li>Provides server session management APIs to manage
memory-resident SSL sessions</li>

<li>Provides support for the certificate status request extension (OCSP stapling), which saves client certificate validation round-trips and resources</li>
<li>Provides support for the Server Name Indication (SNI) extension, which extends the TLS protocols to indicate what server name the client is attempting to connect to during handshaking</li>
<li>Provides support for endpoint identification during handshaking, which prevents man-in-the-middle attacks</li>
<li>Provides support for cryptographic algorithm constraints, which provides fine-grained control over algorithms negotiated by JSSE</li>

</ul>

<!-- *********************************************** -->
<h3><a name="StandardAPI" id="StandardAPI">JSSE Standard
API</a></h3>
<p>The JSSE standard API, available in the <code>javax.net</code>
and <code>javax.net.ssl</code> packages, provides:</p>
<ul>
<li>Secure sockets and server sockets.</li>
<li>A nonblocking engine for producing and consuming streams of
TLS data (<code>SSLEngine</code>).</li>
<li>Factories for creating sockets, server sockets, SSL sockets,
and SSL server sockets. By using socket factories, you can
encapsulate socket creation and configuration behavior.</li>
<li>A class representing a secure socket context that acts as a
factory for secure socket factories and engines.</li>
<li>Key and trust manager interfaces (including X.509-specific key
and trust managers), and factories that can be used for creating
them.</li>
<li>A class for secure HTTP URL connections (HTTPS).</li>
</ul>
<!-- *********************************************** -->
<h3><a name="SunJSSE" id="SunJSSE">SunJSSE Provider</a></h3>
<p>Oracle's implementation of Java SE includes a JSSE provider
named <code>SunJSSE</code>, which comes preinstalled and preregistered
with the JCA. This provider supplies the following cryptographic
services:</p>
<ul>
<li>An implementation of the security protocols SSL 3.0 and TLS 1.0, 1.1, 1.2, and 1.3 (since JDK 8u261).</li>
<li>An implementation of the most common TLS cipher suites,
which encompass a combination of authentication, key agreement,
encryption, and integrity protection.</li>
<li>An implementation of an X.509-based key manager that chooses
appropriate authentication keys from a standard JCA keystore.</li>
<li>An implementation of an X.509-based trust manager that
implements rules for certificate chain path validation.</li>
<li>An implementation of PKCS12 as JCA keystore type "pkcs12".
Storing trust anchors in PKCS12 is not supported. Users should
store trust anchors in the Java keystore (JKS) format and save
private keys in PKCS12 format.</li>
</ul>
<p>More information about this provider is available in the
<a href="../SunProviders.html#SunJSSEProvider">SunJSSE</a> section
of the Oracle Providers Documentation.</p>
<!-- *********************************************** -->
<h3><a name="RelatedDocs" id="RelatedDocs">Related Documentation</a></h3>
<p>The following list contains links to online documentation and
names of books about related subjects:</p>

<ul>
<li><b>JSSE API Documentation</b>
<ul>
<li><a href="../../../../api/javax/net/package-summary.html"><code>javax.net</code> package</a></li>
<li><a href="../../../../api/javax/net/ssl/package-summary.html"><code>javax.net.ssl</code> package</a></li>
<li><a href="../../../../api/javax/security/cert/package-summary.html"><code>javax.security.cert</code> package</a></li>
</ul>
</li>
<li><b>Java SE Security</b>
<ul>
<li>The <a href="../index.html">Java SE Security Documentation</a> index page</li>
<li>The <a href="https://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html">Java SE Security</a> home page</li>
<li>The <a href="https://docs.oracle.com/javase/tutorial/security/">Security Features in Java SE</a> trail of the Java Tutorial</li>
<li><a href="../certpath/CertPathProgGuide.html">Java PKI Programmer's Guide</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javaee/gong-135902.html">Inside Java 2 Platform Security, Second Edition: Architecture, API Design and Implementation</a></li>
</ul>
</li>
<li><b>Transport Layer Security (TLS)</b>
<ul>
<li><a href="https://www.ietf.org/rfc/rfc2246.txt">The TLS Protocol Version 1.0</a></li>
<li><a href="https://www.ietf.org/rfc/rfc4346.txt">The TLS Protocol Version 1.1</a></li>
<li><a href="https://www.ietf.org/rfc/rfc5246.txt">The TLS Protocol Version 1.2</a></li>
<li><a href="https://tools.ietf.org/html/rfc8446">The TLS Protocol Version 1.3</a></li>
<li><a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions</a></li>
<li><a href="https://www.ietf.org/rfc/rfc2818.txt">HTTP Over TLS</a></li>
</ul>
</li>

<li><b>U.S. Encryption Policies</b>
<ul>
<li><a href="https://www.commerce.gov/">U.S. Department of Commerce</a></li>
<li><a href="http://www.techceocouncil.org/">Technology CEO Council</a></li>
<li>Current export policies: <a href="https://www.bis.doc.gov/index.php/policy-guidance/encryption">Encryption and Export Administration Regulations (EAR)</a></li>
<li><a href="https://csrc.nist.gov/publications">NIST Computer Security Publications</a></li>
</ul>
</li>
</ul>

<!-- *********************************************** -->
<h2><a name="Terms" id="Terms">Terms and Definitions</a></h2>
<p>Several terms relating to cryptography are used within this
document. This section defines some of these terms.</p>
<dl>
<dt><b>authentication</b></dt>
<dd>
<p>The process of confirming the identity of a party with whom one
is communicating.</p>
</dd>
<dt><a name="CipherSuite" id="CipherSuite"><b>cipher
suite</b></a></dt>
<dd>
<p>A combination of cryptographic parameters that define the
security algorithms and key sizes used for authentication, key
agreement, encryption, and integrity protection.</p>
</dd>
<dt><b>certificate</b></dt>
<dd>
<p>A digitally signed statement vouching for the identity and
public key of an entity (person, company, and so on). Certificates
can either be self-signed or issued by a Certificate Authority (CA)
&mdash; an entity that is trusted to issue valid
certificates for other entities. Well-known CAs include VeriSign,
Entrust, and GTE CyberTrust. X509 is a common certificate format
that can be managed by the JDK's <code>keytool</code>.</p>
</dd>
<dt><b>cryptographic hash function</b></dt>
<dd>
<p>An algorithm that is used to produce a relatively small
fixed-size string of bits (called a hash) from an arbitrary block
of data. A cryptographic hash function is similar to a checksum and
has three primary characteristics: it is a one-way function,
meaning that it is not possible to produce the original data from
the hash; a small change in the original data produces a large
change in the resulting hash; and it does not require a
cryptographic key.</p>
</dd>
<dt><b>Cryptographic Service Provider</b></dt>
<dd>
<p>Sometimes referred to simply as <a href=
"../crypto/CryptoSpec.html#ProviderArch"><dfn>provider</dfn></a>
for short, the Java Cryptography Architecture (JCA) defines it as a
package (or set of packages) that implements one or more engine
classes for specific cryptographic algorithms. An engine class
defines a cryptographic service in an abstract fashion without a
concrete implementation.</p>
</dd>
<dt><b>decryption</b></dt>
<dd>
<p>See <a href="#EncrDecr">encryption/decryption</a>.</p>
</dd>
<dt><b>digital signature</b></dt>
<dd>
<p>A digital equivalent of a handwritten signature. It is used to
ensure that data transmitted over a network was sent by whoever
claims to have sent it and that the data has not been modified in
transit. For example, an RSA-based digital signature is calculated
by first computing a cryptographic hash of the data and then
encrypting the hash with the sender's private key.</p>
</dd>
<dt><a name="EncrDecr" id=
"EncrDecr"><b>encryption</b>/<b>decryption</b></a></dt>
<dd>
<p>Encryption is the process of using a complex algorithm to
convert an original message (<dfn>cleartext</dfn>) to an encoded
message (<dfn>ciphertext</dfn>) that is unintelligible unless it is
decrypted. Decryption is the inverse process of producing cleartext
from ciphertext.</p>
<p>The algorithms used to encrypt and decrypt data typically come
in two categories: secret key (<dfn>symmetric</dfn>) cryptography
and public key (<dfn>asymmetric</dfn>) cryptography.</p>
</dd>
<dt><b>handshake protocol</b></dt>
<dd>
<p>The negotiation phase during which the two socket peers agree to
use a new or existing session. The handshake protocol is a series
of messages exchanged over the record protocol. At the end of the
handshake, new connection-specific encryption and integrity
protection keys are generated based on the key agreement secrets in
the session.</p>
</dd>
<dt><b>key agreement</b></dt>
<dd>
<p>A method by which two parties cooperate to establish a common
key. Each side generates some data, which is exchanged. These two
pieces of data are then combined to generate a key. Only those
holding the proper private initialization data can obtain the final
key. Diffie-Hellman (DH) is the most common example of a key
agreement algorithm.</p>
</dd>
<dt><b>key exchange</b></dt>
<dd>
<p>A method by which keys are exchanged. One side generates a
private key and encrypts it using the peer's public key (typically
RSA). The data is transmitted to the peer, who decrypts the key
using the corresponding private key.</p>
</dd>
<dt><a name="KMandTMdef" id="KMandTMdef"><b>key
manager</b>/<b>trust manager</b></a></dt>
<dd>
<p>Key managers and trust managers use keystores for their key
material. A key manager manages a keystore and supplies public keys
to others as needed (for example, for use in authenticating the
user to others). A trust manager decides who to trust based on
information in the truststore it manages.</p>
</dd>
<dt><a name="Stores" id=
"Stores"><b>keystore</b>/<b>truststore</b></a></dt>
<dd>
<p>A keystore is a database of key material. Key material is used
for a variety of purposes, including authentication and data
integrity. Various types of keystores are available, including
PKCS12 and Oracle's JKS.</p>
<p>Generally speaking, keystore information can be grouped into two
categories: key entries and trusted certificate entries. A key
entry consists of an entity's identity and its private key, and can
be used for a variety of cryptographic purposes. In contrast, a
trusted certificate entry contains only a public key in addition to
the entity's identity. Thus, a trusted certificate entry cannot be
used where a private key is required, such as in a
<code>javax.net.ssl.KeyManager</code>. In the JDK implementation of
JKS, a keystore may contain both key entries and trusted
certificate entries.</p>
<p>A truststore is a keystore that is used when making decisions
about what to trust. If you receive data from an entity that you
already trust, and if you can verify that the entity is the one
that it claims to be, then you can assume that the data really came
from that entity.</p>
<p>An entry should only be added to a truststore if the user trusts
that entity. By either generating a key pair or by importing a
certificate, the user gives trust to that entry. Any entry in the
truststore is considered a trusted entry.</p>
<p>It may be useful to have two different keystore files: one
containing just your key entries, and the other containing your
trusted certificate entries, including CA certificates. The former
contains private information, whereas the latter does not. Using
two files instead of a single keystore file provides a cleaner
separation of the logical distinction between your own certificates
(and corresponding private keys) and others' certificates. To
provide more protection for your private keys, store them in a
keystore with restricted access, and provide the trusted
certificates in a more publicly accessible keystore if needed.</p>
</dd>
<dt><b>message authentication code (MAC)</b></dt>
<dd>
<p>Provides a way to check the integrity of information transmitted
over or stored in an unreliable medium, based on a secret key.
Typically, MACs are used between two parties that share a secret
key in order to validate information transmitted between these
parties.</p>
<p>A MAC mechanism that is based on cryptographic hash functions is
referred to as HMAC. HMAC can be used with any cryptographic hash
function, such as Secure Hash Algorithm
(SHA-256), in combination with a secret shared key. HMAC is specified
in RFC 2104.</p>
</dd>
<dt><b>public-key cryptography</b></dt>
<dd>
<p>A cryptographic system that uses an encryption algorithm in
which two keys are produced. One key is made public, whereas the
other is kept private. The public key and the private key are
cryptographic inverses; what one key encrypts only the other key
can decrypt. Public-key cryptography is also called <dfn>asymmetric
cryptography</dfn>.</p>
</dd>
<dt><b>Record Protocol</b></dt>
<dd>
<p>A protocol that packages all data (whether application-level or
as part of the handshake process) into discrete records of data
much like a TCP stream socket converts an application byte stream
into network packets. The individual records are then protected by
the current encryption and integrity protection keys.</p>
</dd>
<dt><b>secret-key cryptography</b></dt>
<dd>
<p>A cryptographic system that uses an encryption algorithm in
which the same key is used both to encrypt and decrypt the data.
Secret-key cryptography is also called <dfn>symmetric
cryptography</dfn>.</p>
</dd>
<dt><b>session</b></dt>
<dd>
<p>A named collection of state information including authenticated
peer identity, cipher suite, and key agreement secrets that are
negotiated through a secure socket handshake and that can be shared
among multiple secure socket instances.</p>
</dd>
<dt><b>trust manager</b></dt>
<dd>
<p>See <a href="#KMandTMdef">key manager/trust manager</a>.</p>
</dd>
<dt><b>truststore</b></dt>
<dd>
<p>See <a href="#Stores">keystore/truststore</a>.</p>
</dd>
</dl>
<!-- *********************************************** -->

<h2><a name="tls-protocol-overview">Transport Layer Security (TLS) Protocol Overview</a></h2>

<p>Transport Layer Security (TLS) is the most widely used
protocol for implementing cryptography on the web. TLS uses a
combination of cryptographic processes to provide secure
communication over a network. The page <a href="tls.html">Transport Layer Security (TLS) Protocol Overview</a>
provides an introduction to TLS and the cryptographic processes it uses.</p>

<!-- *********************************************** -->
<h2><a name="JSSEClasses" id="JSSEClasses">JSSE Classes and
Interfaces</a></h2>
<p>To communicate securely, both sides of the connection must be
SSL-enabled. In the JSSE API, the endpoint classes of the
connection are <code>SSLSocket</code> and <code>SSLEngine</code>.
In the figure <a href="#Fig2">JSSE Classes Used to Create SSLSocket and
SSLEngine</a>, the major classes used to create
<code>SSLSocket</code> and <code>SSLEngine</code> are laid out in a
logical ordering. The text following the diagram, explains the
contents of the illustration.</p>
<div>
<div class="caption"><a name="Fig2" id="Fig2">Classes
Used to Create SSLSocket and SSLEngine</a></div>
<img src="images/jsse-classes-and-interfaces.png" width="459" height="333"
alt="This image illustrates the JSSE classes required to create SSLEngine
and SSLSocket classes. The image also describes the JSSE classes and
interfaces and their relationships. The sections following this image
describe these classes and interfaces." /></div>
<p>An <code>SSLSocket</code> is created either by an
<code>SSLSocketFactory</code> or by an <code>SSLServerSocket</code>
accepting an inbound connection. In turn, an
<code>SSLServerSocket</code> is created by an
<code>SSLServerSocketFactory</code>. Both
<code>SSLSocketFactory</code> and
<code>SSLServerSocketFactory</code> objects are created by an
<code>SSLContext</code>. An <code>SSLEngine</code> is created
directly by an <code>SSLContext</code>, and relies on the
application to handle all I/O.</p>
<hr />
<p><strong>Note:</strong> When using raw <code>SSLSocket</code> or
<code>SSLEngine</code> classes, you should always check the peer's
credentials before sending any data. Since JDK 7, endpoint
identification/verification procedures can be handled during
SSL/TLS handshaking. See the method
<code>SSLParameters.setEndpointIdentificationAlgorithm</code>. For
example, the host name in a URL should match the host name in the
peer's credentials. An application could be exploited with URL
spoofing if the host name is not verified.</p>
<hr />

<!-- *********************************************** -->
<h3><a name="CoreClasses" id="CoreClasses">Core Classes and
Interfaces</a></h3>
<p>The core JSSE classes are part of the <code>javax.net</code> and
<code>javax.net.ssl</code> packages.</p>
<!-- *********************************************** -->
<h3><a name="SocketFactory" id="SocketFactory">SocketFactory and
ServerSocketFactory Classes</a></h3>
<p>The abstract <code>javax.net.SocketFactory</code> class is used
to create sockets. Subclasses of this class are factories that
create particular subclasses of sockets and thus provide a general
framework for the addition of public socket-level functionality.
For example, see <a href="#SSLSocketFactory">SSLSocketFactory and
SSLServerSocketFactory</a>.</p>
<p>The abstract <code>javax.net.ServerSocketFactory</code> class is
analogous to the <code>SocketFactory</code> class, but is used
specifically for creating server sockets.</p>
<p>Socket factories are a simple way to capture a variety of
policies related to the sockets being constructed, producing such
sockets in a way that does not require special configuration of the
code that asks for the sockets:</p>
<ul>
<li>Due to polymorphism of both factories and sockets, different
kinds of sockets can be used by the same application code just by
passing different kinds of factories.</li>
<li>Factories can themselves be customized with parameters used in
socket construction. For example, factories could be customized to
return sockets with different networking timeouts or security
parameters already configured.</li>
<li>The sockets returned to the application can be subclasses of
<code>java.net.Socket</code> (or
<code>javax.net.ssl.SSLSocket</code>), so that they can directly
expose new APIs for features such as compression, security, record
marking, statistics collection, or firewall tunneling.</li>
</ul>
<!-- *********************************************** -->
<h3><a name="SSLSocketFactory" id=
"SSLSocketFactory">SSLSocketFactory and SSLServerSocketFactory
Classes</a></h3>
<p>The <code>javax.net.ssl.SSLSocketFactory</code> class acts as a
factory for creating secure sockets. This class is an abstract
subclass of <a href=
"#SocketFactory">javax.net.SocketFactory</a>.</p>
<p>Secure socket factories encapsulate the details of creating and
initially configuring secure sockets. This includes authentication
keys, peer certificate validation, enabled cipher suites, and the
like.</p>
<p>The <code>javax.net.ssl.SSLServerSocketFactory</code> class is
analogous to the <code>SSLSocketFactory</code> class, but is used
specifically for creating server sockets.</p>
<!-- *********************************************** -->
<h4>Obtaining an SSLSocketFactory</h4>
<p>The following ways can be used to obtain an
<code>SSLSocketFactory</code>:</p>
<ul>
<li>Get the default factory by calling the
<code>SSLSocketFactory.getDefault()</code> static method.</li>
<li>Receive a factory as an API parameter. That is, code that must
create sockets but does not care about the details of how the
sockets are configured can include a method with an
<code>SSLSocketFactory</code> parameter that can be called by
clients to specify which <code>SSLSocketFactory</code> to use when
creating sockets (for example,
<code>javax.net.ssl.HttpsURLConnection</code>).</li>
<li>Construct a new factory with specifically configured
behavior.</li>
</ul>
<p>The default factory is typically configured to support server
authentication only so that sockets created by the default factory
do not leak any more information about the client than a normal TCP
socket would.</p>
<p>Many classes that create and use sockets do not need to know the
details of socket creation behavior. Creating sockets through a
socket factory passed in as a parameter is a good way of isolating
the details of socket configuration, and increases the reusability
of classes that create and use sockets.</p>
<p>You can create new socket factory instances either by
implementing your own socket factory subclass or by using another
class which acts as a factory for socket factories. One example of
such a class is <code>SSLContext</code>, which is provided with the
JSSE implementation as a provider-based configuration class.</p>
<!-- *********************************************** -->
<h3><a name="SSLSocket" id="SSLSocket">SSLSocket and
SSLServerSocket Classes</a></h3>
<p>The <code>javax.net.ssl.SSLSocket</code> class is a subclass of
the standard Java <code>java.net.Socket</code> class. It supports
all of the standard socket methods and adds methods specific to
secure sockets. Instances of this class encapsulate the <a href=
"#SSLContext">SSLContext</a> under which they were created. There
are APIs to control the creation of secure socket sessions for a
socket instance, but trust and key management are not directly
exposed.</p>
<p>The <code>javax.net.ssl.SSLServerSocket</code> class is
analogous to the <code>SSLSocket</code> class, but is used
specifically for creating server sockets.<br /></p>
<p>To prevent peer spoofing, you should always verify the credentials
presented to an <code>SSLSocket</code>. See <a href=
"#ciphersuitechoice">Cipher Suite Choice and Remote Entity
Verification</a>.</p>
<hr />
<p><strong>Note:</strong> Due to the complexity of the SSL and TLS
protocols, it is difficult to predict whether incoming bytes on a
connection are handshake or application data, and how that data
might affect the current connection state (even causing the process
to block). In the Oracle JSSE implementation, the
<code>available()</code> method on the object obtained by
<code>SSLSocket.getInputStream()</code> returns a count of the
number of application data bytes successfully decrypted from the
SSL connection but not yet read by the application.</p>
<hr />
<!-- *********************************************** -->
<h4>Obtaining an SSLSocket</h4>
Instances of <code>SSLSocket</code> can be obtained in one of the
following ways:
<ul>
<li>An <code>SSLSocket</code> can be created by an instance of
<a href="#SSLSocketFactory">SSLSocketFactory</a> via one of the
several <code>createSocket()</code> methods of that class.</li>
<li>An <code>SSLSocket</code> can be created through the
<code>accept()</code> method of the <code>SSLServerSocket</code>
class.</li>
</ul>
<!-- *********************************************** -->
<h4><a name="ciphersuitechoice">Cipher Suite Choice and Remote Entity Verification</a></h4>

<p>The SSL/TLS protocols define a specific series of steps to ensure
a protected connection. However, the choice of cipher suite directly
affects the type of security that the connection enjoys. For example,
if an anonymous cipher suite is selected, then the application has
no way to verify the remote peer's identity. If a suite with no
encryption is selected, then the privacy of the data cannot be
protected. Additionally, the SSL/TLS protocols do not specify that
the credentials received must match those that peer might be expected
to send. If the connection were somehow redirected to a rogue peer,
but the rogue's credentials were acceptable based on the current
trust material, then the connection would be considered valid.</p>

<p>When using raw <code>SSLSocket</code> and <code>SSLEngine</code>
classes, you should always check the peer's credentials before
sending any data. The <code>SSLSocket</code> and <code>SSLEngine</code>
classes do not automatically verify that the host name in a URL
matches the host name in the peer's credentials. An application could
be exploited with URL spoofing if the host name is not verified.
Since JDK 7, endpoint identification/verification procedures can be
handled during SSL/TLS handshaking. See the
<code>SSLParameters.getEndpointIdentificationAlgorithm</code> method.</p>

<p>Protocols such as HTTPS (HTTP Over TLS) do require host name
verification. Since JDK 7, the HTTPS endpoint identification is
enforced during handshaking for <code>HttpsURLConnection</code> by
default. See the
<code>SSLParameters.getEndpointIdentificationAlgorithm</code> method.
Alternatively, applications can use the <code>HostnameVerifier</code>
interface to override the default HTTPS host name rules.

<!-- *********************************************** -->
<h3><a name="SSLEngine" id="SSLEngine">SSLEngine Class</a></h3>
<p>TLS is becoming increasingly popular. It is being used in a
wide variety of applications across a wide range of computing
platforms and devices. Along with this popularity come demands to
use TLS with different I/O and threading models to satisfy the
applications' performance, scalability, footprint, and other
requirements. There are demands to use TLS with blocking and
nonblocking I/O channels, asynchronous I/O, arbitrary input and
output streams, and byte buffers. There are demands to use it in
highly scalable, performance-critical environments, requiring
management of thousands of network connections.</p>
<p>Abstraction of the I/O transport mechanism using the
<code>SSLEngine</code> class in Java SE allows applications to use
the TLS protocol in a transport-independent way, and thus
frees application developers to choose transport and computing
models that best meet their needs. Not only does this abstraction
allow applications to use nonblocking I/O channels and other I/O
models, it also accommodates different threading models. This
effectively leaves the I/O and threading decisions up to the
application developer. Because of this flexibility, the application
developer must manage I/O and threading (complex topics in and of
themselves), as well as have some understanding of the SSL/TLS
protocols. The abstraction is therefore an advanced API: beginners
should use <code>SSLSocket</code>.</p>
<p>Users of other Java programming language APIs such as the Java
Generic Security Services (Java GSS) and the Java Simple
Authentication Security Layer (Java SASL) will notice similarities
in that the application is also responsible for transporting
data.</p>
<p>The core class is <a href=
"../../../../api/javax/net/ssl/SSLEngine.html">
<code>javax.net.ssl.SSLEngine</code></a>.
It encapsulates a TLS state machine and operates on inbound
and outbound byte buffers supplied by the user of the
<code>SSLEngine</code> class. The diagram
<a href="#Fig3">Flow of Data Through SSLEngine</a> illustrates the
flow of data from the application, through <code>SSLEngine</code>,
to the transport mechanism, and back.</p>
<div>
<div class="caption"><a name="Fig3" id="Fig3">Flow of
Data Through SSLEngine</a></div>
<img src="images/sslengine_jsse.png" width="458" height="203" align="top"
border="0" alt="The following text describes this figure." /></div>

<p>The application, shown on the left, supplies application
(plaintext) data in an application buffer and passes it to
<code>SSLEngine</code>. The <code>SSLEngine</code> object processes
the data contained in the buffer, or any handshaking data, to
produce TLS encoded data and places it to the network buffer
supplied by the application. The application is then responsible
for using an appropriate transport (shown on the right) to send the
contents of the network buffer to its peer. Upon receiving TLS
encoded data from its peer (via the transport), the application
places the data into a network buffer and passes it to
<code>SSLEngine</code>. The <code>SSLEngine</code> object processes
the network buffer's contents to produce handshaking data or
application data.</p>
<p>An instance of the <code>SSLEngine</code> class can be in one of
the following states:</p>
<ul>
<li><b>Creation:</b> The <code>SSLEngine</code> has been created and
initialized, but has not yet been used. During this phase, an
application may set any <code>SSLEngine</code>-specific settings
(enabled cipher suites, whether the <code>SSLEngine</code> should
handshake in client or server mode, and so on). Once handshaking has
begun, though, any new settings (except client/server mode) will be
used for the next handshake. </li>
<li><b>Initial handshaking:</b> The initial handshake is a procedure
by which the two peers exchange communication parameters until an
<code>SSLSession</code> is established. Application data can't be sent
during this phase.</li>
<li><b>Application data:</b> After the communication parameters have
been established and the handshake is complete, application data can
flow through the <code>SSLEngine</code>. Outbound application messages
are encrypted and integrity protected, and inbound messages reverse
the process.</li>
<li><b>Rehandshaking:</b> Either side can request a renegotiation of
the session at any time during the Application Data phase. New
handshaking data can be intermixed among the application data.
Before starting the rehandshake phase, the application may reset the
TLS communication parameters such as the list of enabled cipher
suites and whether to use client authentication, but can not change
between client/server modes. As before, after handshaking has begun,
any new <code>SSLEngine</code> configuration settings won't be used
until the next handshake. </li>
<li><b>Closure:</b> When the connection is no longer needed, the
application should close the <code>SSLEngine</code> and should
send/receive any remaining messages to the peer before closing the
underlying transport mechanism. Once an engine is closed, it is not
reusable: a new <code>SSLEngine</code> must be created.</li>
</ul>
<!-- *********************************************** -->

<h4><a name="OperationStatus" id="OperationStatus">Understanding SSLEngine Operation Statuses</a></h4>

<p>To indicate the status of the engine and what actions the
application should take, the <code>SSLEngine.wrap()</code> and
<code>SSLEngine.unwrap()</code> methods return an <a href=
"../../../../api/javax/net/ssl/SSLEngineResult.html">
<code>SSLEngineResult</code></a> instance, as shown in the example
<a href="#ex2">Using a Nonblocking SocketChannel</a>. This
<code>SSLEngineResult</code> object contains two pieces of status
information: the overall status of the engine and the handshaking
status.</p>
<p>The possible overall statuses are represented by the
<code>SSLEngineResult.Status</code> enum. The following statuses
are available:</p>
<ul>
<li><code>OK</code><br />
There was no error.</li>
<li><code>CLOSED</code><br />
The operation closed the <code>SSLEngine</code> or the operation
could not be completed because it was already closed.</li>
<li><code>BUFFER_UNDERFLOW</code><br />
The input buffer had insufficient data, indicating that the
application must obtain more data from the peer (for example, by
reading more data from the network).</li>
<li><code>BUFFER_OVERFLOW</code><br />
The output buffer had insufficient space to hold the result,
indicating that the application must clear or enlarge the
destination buffer.</li>
</ul>

<p>The example <a href="#ex4">Handling BUFFER_UNDERFLOW and
BUFFER_OVERFLOW</a> illustrates how to handle the
<code>BUFFER_UNDERFLOW</code> and <code>BUFFER_OVERFLOW</code>
statuses of the <code>SSLEngine.unwrap()</code> method. It uses
<code>SSLSession.getApplicationBufferSize()</code> and
<code>SSLSession.getPacketBufferSize()</code> to determine how
large to make the byte buffers.</p>

<div>
<div class="caption"><a name="ex4" id="ex4">Handling BUFFER_UNDERFLOW and
BUFFER_OVERFLOW</a></div>
<pre class="codeblock">
SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
switch (res.getStatus()) {

case BUFFER_OVERFLOW:
// Maybe need to enlarge the peer application data buffer.
if (engine.getSession().getApplicationBufferSize() &gt; peerAppData.capacity()) {
// enlarge the peer application data buffer
} else {
// compact or clear the buffer
}
// retry the operation
break;

case BUFFER_UNDERFLOW:
// Maybe need to enlarge the peer network packet buffer
if (engine.getSession().getPacketBufferSize() &gt; peerNetData.capacity()) {
// enlarge the peer network packet buffer
} else {
// compact or clear the buffer
}
// obtain more inbound network data and then retry the operation
break;

// Handle other status: CLOSED, OK
...
}
</pre></div>

<p>The possible handshaking statuses are represented by the
<code>SSLEngineResult.HandshakeStatus</code> enum. They represent
whether handshaking has completed, whether the caller must obtain
more handshaking data from the peer or send more handshaking data
to the peer, and so on. The following handshake statuses are available:</p>

<ul>
<li><code>FINISHED</code><br/>
The <code>SSLEngine</code> has just finished handshaking.</li>
<li><code>NEED_TASK</code><br/>
The <code>SSLEngine</code> needs the results of one (or more)
delegated tasks before handshaking can continue.</li>
<li><code>NEED_UNWRAP</code><br/>
The <code>SSLEngine</code> needs to receive data from the remote
side before handshaking can continue.</li> 
<li><code>NEED_UNWRAP_AGAIN</code><br/>
The <code>SSLEngine</code> needs to unwrap before handshaking can
continue. This value indicates that not-yet-interpreted data has
been previously received from the remote side and does not need
to be received again; the data has been brought into the JSSE
framework but has not been processed yet.</li> 
<li><code>NEED_WRAP</code><br/>
The <code>SSLEngine</code> must send data to the remote side
before handshaking can continue, so <code>SSLEngine.wrap()</code>
should be called.</li> 
<li><code>NOT_HANDSHAKING</code><br/>
The <code>SSLEngine</code> is not currently handshaking.</li>
</ul>    

<p>Having two statuses per result allows the <code>SSLEngine</code> to
indicate that the application must take two actions: one in response to
the handshaking and one representing the overall status of the
<code>wrap()</code> and <code>unwrap()</code> methods. For example,
the engine might, as the result of a single
<code>SSLEngine.unwrap()</code> call, return
<code>SSLEngineResult.Status.OK</code> to indicate that the input
data was processed successfully and
<code>SSLEngineResult.HandshakeStatus.NEED_UNWRAP</code> to
indicate that the application should obtain more TLS encoded
data from the peer and supply it to <code>SSLEngine.unwrap()</code>
again so that handshaking can continue. As you can see, the
previous examples were greatly simplified; they would need to be
expanded significantly to properly handle all of these
statuses.</p>

<p>The example <a href="#ex5">Checking and Processing Handshaking Statuses and Overall Statuses</a> illustrates how to process
handshaking data by checking handshaking status and the overall
status of the <code>wrap()</code> and <code>unwrap()</code>
methods.</p>
<div>
<div class="caption"><a name="ex5" id="ex5">Checking and
Processing Handshaking Statuses and Overall Statuses</a></div>
<pre class="codeblock">
void doHandshake(SocketChannel socketChannel, SSLEngine engine,
ByteBuffer myNetData, ByteBuffer peerNetData) throws Exception {

// Create byte buffers to use for holding application data
int appBufferSize = engine.getSession().getApplicationBufferSize();
ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);

// Begin handshake
engine.beginHandshake();
SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();

// Process handshaking message
while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

switch (hs) {

case NEED_UNWRAP:
// Receive handshaking data from peer
if (socketChannel.read(peerNetData) &lt; 0) {
// The channel has reached end-of-stream
}

// Process incoming handshaking data
peerNetData.flip();
SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
peerNetData.compact();
hs = res.getHandshakeStatus();

// Check status
switch (res.getStatus()) {
case OK :
// Handle OK status
break;

// Handle other status: BUFFER_UNDERFLOW, BUFFER_OVERFLOW, CLOSED
...
}
break;

case NEED_WRAP :
// Empty the local network packet buffer.
myNetData.clear();

// Generate handshaking data
res = engine.wrap(myAppData, myNetData);
hs = res.getHandshakeStatus();

// Check status
switch (res.getStatus()) {
case OK :
myNetData.flip();

// Send the handshaking data to peer
while (myNetData.hasRemaining()) {
socketChannel.write(myNetData);
}
break;

// Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
...
}
break;

case NEED_TASK :
// Handle blocking tasks
break;

// Handle other status:  // FINISHED or NOT_HANDSHAKING
...
}
}

// Processes after handshaking
...
}
</pre></div>

<!-- *********************************************** -->

<h4>SSLEngine for TLS Protocols</h4>
<p>This section shows you how to create an SSLEngine object and use it to
generate and process TLS data.</p>

<!-- *********************************************** -->

<h5><a name="creating-an-sslengine-object">Creating an SSLEngine Object</a></h5>

<p>To create an <code>SSLEngine</code> object, you use the
<code>SSLContext.createSSLEngine()</code> method. You must
configure the engine to act as a client or a server, and set other
configuration parameters, such as which cipher suites to use and
whether to require client authentication. The
<code>SSLContext.createSSLEngine</code> method creates a
<code>javax.net.ssl.SSLEngine</code> object. </p>

<p>The example <a href="#ex1">Creating an SSLEngine Client for TLS with JKS
as Keystore</a> illustrates how to create an <code>SSLEngine</code> client
for TLS that uses JKS as keystore.</p>

<hr />
<p><strong>Note:</strong> The server name and port number are not
used for communicating with the server (all transport is the
responsibility of the application). They are hints to the JSSE
provider to use for SSL session caching, and for Kerberos-based
cipher suite implementations to determine which server credentials
should be obtained.</p>
<hr />
<div>
<div class="caption"><a name="ex1" id="ex1">Creating an SSLEngine Client for
TLS with JKS as Keystore</a></div>
<pre class="codeblock">import javax.net.ssl.*;
import java.security.*;

// Create and initialize the SSLContext with key material
char[] passphrase = "passphrase".toCharArray();

// First initialize the key and trust material
KeyStore ksKeys = KeyStore.getInstance("JKS");
ksKeys.load(new FileInputStream("testKeys"), passphrase);
KeyStore ksTrust = KeyStore.getInstance("JKS");
ksTrust.load(new FileInputStream("testTrust"), passphrase);

// KeyManagers decide which key material to use
KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");
kmf.init(ksKeys, passphrase);

// TrustManagers decide whether to allow connections
TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
tmf.init(ksTrust);

// Get an instance of SSLContext for TLS protocols
sslContext = SSLContext.getInstance("TLS");
sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

// Create the engine
SSLEngine engine = sslContext.createSSLengine(hostname, port);

// Use as client
engine.setUseClientMode(true);</pre></div>

<!-- *********************************************** -->

<h5><a name="generating-and-processing-tls-data">Generating and Processing TLS Data</a></h5>

<p>The two main <code>SSLEngine</code> methods are
<code>wrap()</code> and <code>unwrap()</code>. They are responsible
for generating and consuming network data respectively. Depending
on the state of the <code>SSLEngine</code> object, this data might
be handshake or application data.</p>

<p>Each <code>SSLEngine</code> object has several phases during its
lifetime. Before application data can be sent or received, the
SSL/TLS protocol requires a handshake to establish cryptographic
parameters. This handshake requires a series of back-and-forth
steps by the <code>SSLEngine</code> object.</p>

<p>During the initial handshaking, the <code>wrap()</code> and
<code>unwrap()</code> methods generate and consume handshake data,
and the application is responsible for transporting the data. The
<code>wrap()</code> and <code>unwrap()</code> method sequence is
repeated until the handshake is finished. Each
<code>SSLEngine</code> operation generates an instance of the
<code>SSLEngineResult</code> class, in which the
<code>SSLEngineResult.HandshakeStatus</code> field is used to
determine what operation must occur next to move the handshake
along.</p>

<p>The figure <a href="#state-machine-during-tls-handshake">State Machine
during TLS Handshake</a> shows the state machine during a typical
TLS handshake, with corresponding messages and statuses:</p>

<div>
<div class="caption"><a name="state-machine-during-tls-handshake"
id="state-machine-during-tls-handshake">State Machine during TLS
Handshake</a></div>
<img src="images/ssl-tls-handshake.png" width="416" height="536" align="top"
border="0" alt="The following text describes this image." /></div>

<p>The following steps are performed before the status of the handshake is
determined:</p>

<ul><li>Create SSL/TLS SSLEngines</li>
<li>Create Buffers</li>
<li>Set Client of Server mode</li>
<li>Begin Handshake</li>
</ul>

<p>This image illustrates some of the possible handshake statuses.
The section <a href="#OperationStatus">Understanding SSLEngine Operation
Statuses</a> describes these statuses in more detail:</p>

<ul><li><code>NEED_TASK</code></li>
<li><code>NEED_WRAP</code></li>
<li><code>NEED_UNWRAP</code></li>
<li><code>FINISHED</code></li></ul>

<p>When handshaking is complete, further calls to
<code>wrap()</code> will attempt to consume application data and
package it for transport. The <code>unwrap()</code> method will
attempt the opposite.</p>

<p>To send data to the peer, the application first supplies the
data that it wants to send via <code>SSLEngine.wrap()</code> to
obtain the corresponding SSL/TLS encoded data. The application then
sends the encoded data to the peer using its chosen transport
mechanism. When the application receives the SSL/TLS encoded data
from the peer via the transport mechanism, it supplies this data to
the <code>SSLEngine</code> via <code>SSLEngine.unwrap()</code> to
obtain the plaintext data sent by the peer.</p>

<p>The example <a href="#ex2">Using a Nonblocking SocketChannel</a> shows
an SSL application that uses a nonblocking <code>SocketChannel</code> to
communicate with its peer.</p>

<hr />
<p><strong>Note:</strong> The example can be made more robust and
scalable by using a <code>Selector</code> with the nonblocking
<code>SocketChannel</code>.</p>
<hr />

<p>In the example <a href="#ex2">Using a Nonblocking SocketChannel</a>,
the string <code>hello</code> is sent to the peer by encoding it using the
<code>SSLEngine</code> created in the example <a href="#ex1">Creating an
SSLEngine Client for TLS with JKS as Keystore</a>. It uses information
from the <code>SSLSession</code> to determine how large the byte buffers
should be.</p>

<div>
<div class="caption"><a name="ex2" id="ex2">Using a Nonblocking
SocketChannel</a></div>
<pre class="codeblock">
// Create a nonblocking socket channel
SocketChannel socketChannel = SocketChannel.open();
socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(hostname, port));

// Complete connection
while (!socketChannel.finishedConnect()) {
// do something until connect completed
}

// Create byte buffers to use for holding application and encoded data
SSLSession session = engine.getSession();
ByteBuffer myAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer myNetData = ByteBuffer.allocate(session.getPacketBufferSize());
ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

// Do initial handshake
doHandshake(socketChannel, engine, myNetData, peerNetData);

myAppData.put("hello".getBytes());
myAppData.flip();

while (myAppData.hasRemaining()) {
// Generate SSL/TLS encoded data (handshake or application data)
SSLEngineResult res = engine.wrap(myAppData, myNetData);

// Process status of call
if (res.getStatus() == SSLEngineResult.Status.OK) {
myAppData.compact();

// Send SSL/TLS encoded data to peer
while(myNetData.hasRemaining()) {
int num = socketChannel.write(myNetData);
if (num == 0) {
// no bytes written; try again later
}
}
}

// Handle other status:  BUFFER_OVERFLOW, CLOSED
...
}
</pre></div>

<p>The example <a href="#ex3">Reading Data From Nonblocking
SocketChannel</a> illustrates how to read data from the same nonblocking
<code>SocketChannel</code> and extract the plaintext data from it by using
the <code>SSLEngine</code> created in the example <a href="#ex1">Creating
an SSLEngine Client for TLS with JKS as Keystore</a>. Each iteration of
this code may or may not produce plaintext data, depending on whether
handshaking is in progress.</p>

<div>
<div class="caption"><a name="ex3" id="ex3">Reading Data From Nonblocking
SocketChannel</a></div>
<pre class="codeblock">
// Read SSL/TLS encoded data from peer
int num = socketChannel.read(peerNetData);
if (num == -1) {
// The channel has reached end-of-stream
} else if (num == 0) {
// No bytes read; try again ...
} else {
// Process incoming data
peerNetData.flip();
res = engine.unwrap(peerNetData, peerAppData);

if (res.getStatus() == SSLEngineResult.Status.OK) {
peerNetData.compact();

if (peerAppData.hasRemaining()) {
// Use peerAppData
}
}
// Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
...
}
</pre></div>
<!-- *********************************************** -->

<h4>Dealing With Blocking Tasks</h4>
<p>During handshaking, an <code>SSLEngine</code> might encounter
tasks that can block or take a long time. For example, a
<code>TrustManager</code> may need to connect to a remote
certificate validation service, or a <code>KeyManager</code> might
need to prompt a user to determine which certificate to use as part
of client authentication. To preserve the nonblocking nature of
<code>SSLEngine</code>, when the engine encounters such a task, it
will return <code>SSLEngineResult.HandshakeStatus.NEED_TASK</code>.
Upon receiving this status, the application should invoke
<code>SSLEngine.getDelegatedTask()</code> to get the task, and
then, using the threading model appropriate for its requirements,
process the task. The application might, for example, obtain
threads from a thread pool to process the tasks, while the main
thread handles other I/O.</p>
<p>The following code executes each task in a newly created
thread:</p>
<pre class="codeblock">
if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
Runnable task;
while ((task = engine.getDelegatedTask()) != null) {
new Thread(task).start();
}
}
</pre>
<p>The <code>SSLEngine</code> will block future <code>wrap()</code>
and <code>unwrap()</code> calls until all of the outstanding tasks
are completed. 
<!-- *********************************************** --></p>
<h4>Shutting Down</h4>
<p>For an orderly shutdown of an SSL/TLS connection, the SSL/TLS
protocols require transmission of close messages. Therefore, when
an application is done with the SSL/TLS connection, it should first
obtain the close messages from the <code>SSLEngine</code>, then
transmit them to the peer using its transport mechanism, and
finally shut down the transport mechanism. <a href="#ex6">Example
6</a> illustrates this.</p>
<div>
<div class="caption"><a name="ex6" id="ex6">Example 6: Shutting
Down an SSL/TLS Connection</a></div>
<pre class="codeblock">
// Indicate that application is done with engine
engine.closeOutbound();

while (!engine.isOutboundDone()) {
// Get close message
SSLEngineResult res = engine.wrap(empty, myNetData);

// Check res statuses

// Send close message to peer
while(myNetData.hasRemaining()) {
int num = socketChannel.write(myNetData);
if (num == 0) {
// no bytes written; try again later
}
myNetData().compact();
}
}

// Close transport
socketChannel.close();
</pre></div>
<p>In addition to an application explicitly closing the
<code>SSLEngine</code>, the <code>SSLEngine</code> might be closed
by the peer (via receipt of a close message while it is processing
handshake data), or by the <code>SSLEngine</code> encountering an
error while processing application or handshake data, indicated by
throwing an <code>SSLException</code>. In such cases, the
application should invoke <code>SSLEngine.wrap()</code> to get the
close message and send it to the peer until
<code>SSLEngine.isOutboundDone()</code> returns <code>true</code>
(as shown in <a href="#ex6">Example 6</a>), or until the
<code>SSLEngineResult.getStatus()</code> returns
<code>CLOSED</code>.</p>
<p>In addition to orderly shutdowns, there can also be unexpected
shutdowns when the transport link is severed before close messages
are exchanged. In the previous examples, the application might get
<code>-1</code> or <tt>IOException</tt> when trying to read from
the nonblocking <code>SocketChannel</code>, or get
<tt>IOException</tt> when trying to write to the non-blocking
<tt>SocketChannel</tt>. When you get to the end of your input data,
you should call <code>engine.closeInbound()</code>, which will
verify with the <code>SSLEngine</code> that the remote peer has
closed cleanly from the SSL/TLS perspective. Then the application
should still try to shut down cleanly by using the procedure in
<a href="#ex6">Example 6</a>. Obviously, unlike
<code>SSLSocket</code>, the application using
<code>SSLEngine</code> must deal with more state transitions,
statuses, and programming. For more information about writing an
<code>SSLEngine</code>-based application, see <a href=
"#SSLEngineSample">Sample Code Illustrating the Use of an
SSLEngine</a>.</p>
<!-- *********************************************** -->
<h3><a name="SSLSession" id="SSLSession">SSLSession and ExtendedSSLSession</a></h3>
<p>The <code>javax.net.ssl.SSLSession</code> interface represents a
security context negotiated between the two peers of an
<code>SSLSocket</code> or <code>SSLEngine</code> connection. After
a session has been arranged, it can be shared by future
<code>SSLSocket</code> or <code>SSLEngine</code> objects connected
between the same two peers.</p>
<p>In some cases, parameters negotiated during the handshake are
needed later in the handshake to make decisions about trust. For
example, the list of valid signature algorithms might restrict the
certificate types that can be used for authentication. The
<code>SSLSession</code> can be retrieved <em>during</em> the
handshake by calling <code>getHandshakeSession()</code> on an
<code>SSLSocket</code> or <code>SSLEngine</code>. Implementations
of <code>TrustManager</code> or <code>KeyManager</code> can use the
<code>getHandshakeSession()</code> method to get information about
session parameters to help them make decisions.</p>
<p>A fully initialized <code>SSLSession</code> contains the cipher
suite that will be used for communications over a secure socket as
well as a nonauthoritative hint as to the network address of the
remote peer, and management information such as the time of
creation and last use. A session also contains a shared master
secret negotiated between the peers that is used to create
cryptographic keys for encrypting and guaranteeing the integrity of
the communications over an <code>SSLSocket</code> or
<code>SSLEngine</code> connection. The value of this master secret
is known only to the underlying secure socket implementation and is
not exposed through the <code>SSLSession</code> API.</p>
<p>In Java SE, a TLS 1.2 session is represented by
<code>ExtendedSSLSession</code>, an implementation of
<code>SSLSession</code>. The <code>ExtendedSSLSession</code> class
adds methods that describe the signature algorithms that are
supported by the local implementation and the peer. The
<code>getRequestedServerNames()</code> method called on an
<code>ExtendedSSLSession</code> instance is used to obtain a list
of <code>SNIServerName</code> objects in the requested <a href=
"#SNIExtension">Server Name Indication (SNI)</a> extension. The
server should use the requested server names to guide its selection
of an appropriate authentication certificate, and/or other aspects
of the security policy. The client should use the requested server
names to guide its endpoint identification of the peer's identity,
and/or other aspects of the security policy.</p>
<p>Calls to the <code>getPacketBufferSize()</code> and
<code>getApplicationBufferSize()</code> methods on
<code>SSLSession</code> are used to determine the appropriate
buffer sizes used by <code>SSLEngine</code>.</p>

<hr />
<a name="LargePackets" id="LargePackets"></a>

<p><strong>Note:</strong> The SSL/TLS protocols specify that
implementations are to produce packets containing at most 16
kilobytes (KB) of plain text. However, some implementations violate
the specification and generate large records up to 32 KB. If the
<code>SSLEngine.unwrap()</code> code detects large inbound packets,
then the buffer sizes returned by <code>SSLSession</code> will be
updated dynamically. Applications should always <a href=
"#OperationStatus">check the <code>BUFFER_OVERFLOW</code> and
<code>BUFFER_UNDERFLOW</code> statuses and enlarge the
corresponding buffers</a> if necessary. <code>SunJSSE</code> will always send
standard compliant 16 KB records and allow incoming 32 KB records.
For a workaround, see the system property
<code>jsse.SSLEngine.acceptLargeFragments</code> in <a href=
"#InstallationAndCustomization">Customizing JSSE</a>.</p>
<hr />

<!-- *********************************************** -->
<h3><a name="HttpsURLConnection" id=
"HttpsURLConnection">HttpsURLConnection Class</a></h3>
<p>The HTTPS protocol is similar to HTTP, but HTTPS first
establishes a secure channel via SSL/TLS sockets and then <a href=
"#ciphersuitechoice">verifies the identity of the peer</a> before
requesting or receiving data. The
<code>javax.net.ssl.HttpsURLConnection</code> class extends the
<code>java.net.HttpsURLConnection</code> class and adds support for
HTTPS-specific features. For more information about how HTTPS URLs
are constructed and used, see the API specification sections about
the <a href=
"../../../../api/java/net/URL.html"><code>java.net.URL</code></a>,
<a href=
"../../../../api/java/net/URLConnection.html"><code>java.net.URLConnection</code></a>,
<a href=
"../../../../api/java/net/HttpURLConnection.html"><code>java.net.HttpURLConnection</code></a>,
and <a href=
"../../../../api/javax/net/ssl/HttpsURLConnection.html"><code>javax.net.ssl.HttpURLConnection</code></a>
classes.</p>
<p>Upon obtaining an <code>HttpsURLConnection</code> instance, you
can configure a number of HTTP and HTTPS parameters before actually
initiating the network connection via the
<code>URLConnection.connect()</code> method. Of particular interest
are:</p>
<ul>
<li><a href="#SettingSSLSocketFactory">Setting the Assigned
SSLSocketFactory</a></li>
<li><a href="#SettingHostnameVerifier">Setting the Assigned
HostnameVerifier</a></li>
</ul>
<!-- *********************************************** -->
<h4><a name="SettingSSLSocketFactory" id=
"SettingSSLSocketFactory">Setting the Assigned
SSLSocketFactory</a></h4>
<p>In some situations, it is desirable to specify the
<code>SSLSocketFactory</code> that an
<code>HttpsURLConnection</code> instance uses. For example, you
might want to tunnel through a proxy type that is not supported by
the default implementation. The new <code>SSLSocketFactory</code>
could return sockets that have already performed all necessary
tunneling, thus allowing <code>HttpsURLConnection</code> to use
additional proxies.</p>
<p>The <code>HttpsURLConnection</code> class has a default
<code>SSLSocketFactory</code> that is assigned when the class is
loaded (this is the factory returned by the
<code>SSLSocketFactory.getDefault()</code> method). Future
instances of <code>HttpsURLConnection</code> will inherit the
current default <code>SSLSocketFactory</code> until a new default
<code>SSLSocketFactory</code> is assigned to the class via the
static <code>HttpsURLConnection.setDefaultSSLSocketFactory()</code>
method. Once an instance of <code>HttpsURLConnection</code> has
been created, the inherited <code>SSLSocketFactory</code> on this
instance can be overridden with a call to the
<code>setSSLSocketFactory()</code> method.</p>
<hr />
<p><strong>Note:</strong> Changing the default static
<code>SSLSocketFactory</code> has no effect on existing instances
of <code>HttpsURLConnection</code>. A call to the
<code>setSSLSocketFactory()</code> method is necessary to change
the existing instances.</p>
<hr />
<p>You can obtain the per-instance or per-class
<code>SSLSocketFactory</code> by making a call to the
<code>getSSLSocketFactory()</code> or
<code>getDefaultSSLSocketFactory()</code> method, respectively.</p>
<!-- *********************************************** -->
<h4><a name="SettingHostnameVerifier" id=
"SettingHostnameVerifier">Setting the Assigned
HostnameVerifier</a></h4>
<p>If the host name of the URL does not match the host name in the
credentials received as part of the SSL/TLS handshake, then it is
possible that URL spoofing has occurred. If the implementation
cannot determine a host name match with reasonable certainty, then
the SSL implementation performs a callback to the instance's
assigned <code>HostnameVerifier</code> for further checking. The
host name verifier can take whatever steps are necessary to make
the determination, such as performing host name pattern matching or
perhaps opening an interactive dialog box. An unsuccessful
verification by the host name verifier closes the connection. For
more information regarding host name verification, see <a href=
"https://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.</p>
<p>The <code>setHostnameVerifier()</code> and
<code>setDefaultHostnameVerifier()</code> methods operate in a
similar manner to the <code>setSSLSocketFactory()</code> and
<code>setDefaultSSLSocketFactory()</code> methods, in that
<code>HostnameVerifier</code> objects are assigned on a
per-instance and per-class basis, and the current values can be
obtained by a call to the <code>getHostnameVerifier()</code> or
<code>getDefaultHostnameVerifier()</code> method.</p>
<!-- *********************************************** -->
<h2><a name="SupportClasses" id="SupportClasses">Support Classes
and Interfaces</a></h2>
<p>The classes and interfaces in this section are provided to
support the creation and initialization of <code>SSLContext</code>
objects, which are used to create <code>SSLSocketFactory</code>,
<code>SSLServerSocketFactory</code>, and <code>SSLEngine</code>
objects. The support classes and interfaces are part of the
<code>javax.net.ssl</code> package.</p>
<p>Three of the classes described in this section (<a href=
"#SSLContext"><code>SSLContext</code></a>, <a href=
"#KeyManagerFactory"><code>KeyManagerFactory</code></a>, and
<a href=
"#TrustManagerFactory"><code>TrustManagerFactory</code></a>) are
<dfn>engine classes</dfn>. An engine class is an API class for
specific algorithms (or protocols, in the case of
<code>SSLContext</code>), for which implementations may be provided
in one or more Cryptographic Service Provider (provider) packages.
For more information about providers and engine classes, see the
"Design Principles" and "Concepts" sections of the <a href=
"../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<p>The <code>SunJSSE</code> provider that comes standard with JSSE provides
<code>SSLContext</code>, <code>KeyManagerFactory</code>, and
<code>TrustManagerFactory</code> implementations, as well as
implementations for engine classes in the standard
<code>java.security</code> API. The following table lists
implementations supplied by <code>SunJSSE</code>.</p>
<table border="1" cellspacing="0" summary="Typical handshake">
<caption><a name="T5" id="T5">Implementations Supplied by SunJSEE</a></caption>
<thead>
<tr>
<th id="class">Engine Class Implemented</th>
<th id="algorithm">Algorithm or Protocol</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1"><code>KeyStore</code></td>
<td headers="h2">PKCS12</td>
</tr>
<tr>
<td headers="h1"><code>KeyManagerFactory</code></td>
<td headers="h2">PKIX, SunX509</td>
</tr>
<tr>
<td headers="h1"><code>TrustManagerFactory</code></td>
<td headers="h2">PKIX (X509 or SunPKIX), SunX509</td>
</tr>
<tr>
<td headers="h1"><code>SSLContext</code></td>
<td headers="h2">SSLv3(<a class="footnote" href=
"../SunProviders.html#sslv2protonote">1</a>), TLSv1, TLSv1.1,
TLSv1.2, TLSv1.3 (since JDK 8u261)</td>
</tr>
</tbody>
</table>
<!-- *********************************************** -->
<h3><a name="SSLContext" id="SSLContext">The SSLContext Class</a></h3>

<p>The <code>javax.net.ssl.SSLContext</code> class is an engine
class for an implementation of a secure socket protocol. An
instance of this class acts as a factory for SSL socket factories
and SSL engines. An <code>SSLContext</code> object holds all of the
state information shared across all objects created under that
context. For example, session state is associated with the
<code>SSLContext</code> when it is negotiated through the handshake
protocol by sockets created by socket factories provided by the
context. These cached sessions can be reused and shared by other
sockets created under the same context.</p>

<p>Each instance is configured through its <code>init</code> method
with the keys, certificate chains, and trusted root CA certificates
that it needs to perform authentication. This configuration is
provided in the form of key and trust managers. These managers
provide support for the authentication and key agreement aspects of
the cipher suites supported by the context.</p>
<p>Currently, only X.509-based managers are supported.</p>

<!-- *********************************************** -->
<h4>Obtaining and Initializing the SSLContext Class</h4>

<p>There are two ways to obtain and initialize an
<code>SSLContext</code>:</p>

<ul>
<li>The simplest way is to call the static
<code>getDefault()</code> method on either the
<code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> class. This method creates a
default <code>SSLContext</code> with a default
<code>KeyManager</code>, <code>TrustManager</code>, and
<code>SecureRandom</code> (a secure random number generator). A
default <code>KeyManagerFactory</code> and
<code>TrustManagerFactory</code> are used to create the
<code>KeyManager</code> and <code>TrustManager</code>,
respectively. The key material used is found in the default
keystore and truststore, as determined by system properties
described in <a href="#CustomizingStores">Customizing the Default
Keystores and Truststores, Store Types, and Store
Passwords</a>.</li>
<li>The approach that gives the caller the most control over the
behavior of the created context is to call the static method
<code>getInstance()</code> on the <code>SSLContext</code> class,
and then initialize the context by calling the instance's proper
<code>init()</code> method. One variant of the <code>init()</code>
method takes three arguments: an array of <code>KeyManager</code>
objects, an array of <code>TrustManager</code> objects, and a
<code>SecureRandom</code> object. The <code>KeyManager</code> and
<code>TrustManager</code> objects are created by either
implementing the appropriate interfaces or using the
<code>KeyManagerFactory</code> and <code>TrustManagerFactory</code>
classes to generate implementations. The
<code>KeyManagerFactory</code> and <code>TrustManagerFactory</code>
can then each be initialized with key material contained in the
<code>KeyStore</code> passed as an argument to the
<code>init()</code> method of the <code>TrustManagerFactory</code>
or <code>KeyManagerFactory</code> classes. Finally, the
<code>getTrustManagers()</code> method (in
<code>TrustManagerFactory</code>) and <code>getKeyManagers()</code>
method (in <code>KeyManagerFactory</code>) can be called to obtain
the array of trust managers or key managers, one for each type of
trust or key material.</li>
</ul>
<p>Once an SSL connection is established, an
<code>SSLSession</code> is created which contains various
information, such as identities established and cipher suite used.
The <code>SSLSession</code> is then used to describe an ongoing
relationship and state information between two entities. Each SSL
connection involves one session at a time, but that session may be
used on many connections between those entities, simultaneously or
sequentially.</p>



<!-- *********************************************** -->
<h4>Creating an SSLContext Object</h4>
<p>Like other JCA provider-based engine classes,
<code>SSLContext</code> objects are created using the
<code>getInstance()</code> factory methods of the
<code>SSLContext</code> class. These static methods each return an
instance that implements <em>at least</em> the requested secure
socket protocol. The returned instance may implement other
protocols, too. For example, <code>getInstance("TLSv1.2")</code> may
return an instance that implements TLSv1, TLSv1.1, and TLSv1.2. The
<code>getSupportedProtocols()</code> method returns a list of
supported protocols when an <code>SSLSocket</code>,
<code>SSLServerSocket</code>, or <code>SSLEngine</code> is created
from this context. You can control which protocols are actually
enabled for an SSL connection by using the
<code>setEnabledProtocols(String[] protocols)</code> method.</p>
<hr />
<p><strong>Note:</strong> An <code>SSLContext</code> object is
automatically created, initialized, and statically assigned to the
<code>SSLSocketFactory</code> class when you call the
<code>SSLSocketFactory.getDefault()</code> method. Therefore, you
do not have to directly create and initialize an
<code>SSLContext</code> object (unless you want to override the
default behavior).</p>
<p>To create an <code>SSLContext</code> object by calling the
<code>getInstance()</code> factory method, you must specify the
protocol name. You may also specify which provider you want to
supply the implementation of the requested protocol:</p>
<ul>
<li><code>public static SSLContext getInstance(String
protocol);</code></li>
<li><code>public static SSLContext getInstance(String protocol,
String provider);</code></li>
<li><code>public static SSLContext getInstance(String protocol,
Provider provider);</code></li>
</ul>
<p>If just a protocol name is specified, then the system will
determine whether an implementation of the requested protocol is
available in the environment. If there is more than one
implementation, then it will determine whether there is a preferred
one.</p>
<p>If both a protocol name and a provider are specified, then the
system will determine whether an implementation of the requested
protocol is in the provider requested. If there is no
implementation, an exception will be thrown.</p>
<p>A protocol is a string (such as <code>"TLS"</code>) that
describes the secure socket protocol desired. Common protocol names
for <code>SSLContext</code> objects are defined in <a href=
"#AppA">Appendix A</a>.</p>
<p>An <code>SSLContext</code> can be obtained as follows:</p>
<pre class="codeblock">
SSLContext sc = SSLContext.getInstance("TLS");
</pre>
<p>A newly created <code>SSLContext</code> should be initialized by
calling the <code>init</code> method:</p>
<pre class="codeblock">
public void init(KeyManager[] km, TrustManager[] tm, SecureRandom random);
</pre>
<p>If the <code>KeyManager[]</code> parameter is null, then an
empty <code>KeyManager</code> will be defined for this context. If
the <code>TrustManager[]</code> parameter is null, then the
installed security providers will be searched for the
highest-priority implementation of the <a href=
"#TrustManagerFactory"><code>TrustManagerFactory</code></a>, from
which an appropriate <code>TrustManager</code> will be obtained.
Likewise, the <code>SecureRandom</code> parameter may be null, in
which case a default implementation will be used.</p>
<p>If the internal default context is used, (for example, an
<code>SSLContext</code> is created by
<code>SSLSocketFactory.getDefault()</code> or
<code>SSLServerSocketFactory.getDefault()</code>), then a <a href=
"#DefaultKTMCust">default <code>KeyManager</code> and
<code>TrustManager</code></a> are created. The default
<code>SecureRandom</code> implementation is also chosen.</p>
<!-- *********************************************** -->
<h3><a name="TrustManager" id="TrustManager">The TrustManager
Interface</a></h3>
<p>The primary responsibility of the <code>TrustManager</code> is
to determine whether the presented authentication credentials
should be trusted. If the credentials are not trusted, then the
connection will be terminated. To authenticate the remote identity
of a secure socket peer, you must initialize an
<code>SSLContext</code> object with one or more
<code>TrustManager</code> objects. You must pass one
<code>TrustManager</code> for each authentication mechanism that is
supported. If null is passed into the <code>SSLContext</code>
initialization, then a trust manager will be created for you.
Typically, a single trust manager supports authentication based on
X.509 public key certificates (for example,
<code>X509TrustManager</code>). Some secure socket implementations
may also support authentication based on shared secret keys,
Kerberos, or other mechanisms.</p>
<p><code>TrustManager</code> objects are created either by a
<code>TrustManagerFactory</code>, or by providing a concrete
implementation of the interface.</p>
<!-- *********************************************** -->
<h3><a name="TrustManagerFactory" id="TrustManagerFactory">The
TrustManagerFactory Class</a></h3>
<p>The <code>javax.net.ssl.TrustManagerFactory</code> is an engine
class for a provider-based service that acts as a factory for one
or more types of <code>TrustManager</code> objects. Because it is
provider-based, additional factories can be implemented and
configured to provide additional or alternative trust managers that
provide more sophisticated services or that implement
installation-specific authentication policies.</p>
<!-- *********************************************** -->
<h4>Creating a TrustManagerFactory</h4>
You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name
string instead of a protocol name to the <code>getInstance()</code>
method:
<pre class="codeblock">
TrustManagerFactory tmf =
TrustManagerFactory.getInstance(String algorithm);

TrustManagerFactory tmf =
TrustManagerFactory.getInstance(String algorithm, String provider);

TrustManagerFactory tmf =
TrustManagerFactory.getInstance(String algorithm, Provider provider);
</pre>
<p>A sample call is as follows:</p>
<pre class="codeblock">
TrustManagerFactory tmf =
TrustManagerFactory.getInstance("PKIX", "SunJSSE");
</pre>
<p>The preceding call creates an instance of the <code>SunJSSE</code> provider's
PKIX trust manager factory. This factory can be used to create
trust managers that provide X.509 PKIX-based certification path
validity checking.</p>
<p>When initializing an <code>SSLContext</code>, you can use trust
managers created from a trust manager factory, or you can write
your own trust manager, for example, using the <a href=
"../../../../api/java/security/cert/CertPath.html"><code>CertPath</code></a>
API. For details, see the <a href=
"../certpath/CertPathProgGuide.html">Java PKI Programmer's
Guide</a>. You do not need to use a trust manager factory if you
implement a trust manager using the <a href=
"../../../../api/javax/net/ssl/X509TrustManager.html"><code>X509TrustManager</code></a>
interface.</p>
<p>A newly created factory should be initialized by calling one of
the <code>init()</code> methods:</p>
<pre class="codeblock">
public void init(KeyStore ks);
public void init(ManagerFactoryParameters spec);
</pre>
<p>Call whichever <code>init()</code> method is appropriate for the
<code>TrustManagerFactory</code> you are using. If you are not
sure, then ask the provider vendor.</p>
<p>For many factories, such as the SunX509
<code>TrustManagerFactory</code> from the <code>SunJSSE</code> provider, the
<code>KeyStore</code> is the only information required to
initialize the <code>TrustManagerFactory</code> and thus the first
<code>init</code> method is the appropriate one to call. The
<code>TrustManagerFactory</code> will query the
<code>KeyStore</code> for information about which remote
certificates should be trusted during authorization checks.</p>
<p>Sometimes, initialization parameters other than a
<code>KeyStore</code> are needed by a provider. Users of that
provider are expected to pass an implementation of the appropriate
<code>ManagerFactoryParameters</code> as defined by the provider.
The provider can then call the specified methods in the
<code>ManagerFactoryParameters</code> implementation to obtain the
needed information.</p>
<p>For example, suppose the <code>TrustManagerFactory</code>
provider requires initialization parameters B, R, and S from any
application that wants to use that provider. Like all providers
that require initialization parameters other than a
<code>KeyStore</code>, the provider requires the application to
provide an instance of a class that implements a particular
<code>ManagerFactoryParameters</code> subinterface. In the example,
suppose that the provider requires the calling application to
implement and create an instance of
<code>MyTrustManagerFactoryParams</code> and pass it to the second
<code>init()</code> method. The following example illustrates what
<code>MyTrustManagerFactoryParams</code> can look like:</p>
<pre class="codeblock">
public interface MyTrustManagerFactoryParams extends ManagerFactoryParameters {
public boolean getBValue();
public float getRValue();
public String getSValue():
}
</pre>
<p>Some trust managers can make trust decisions without being
explicitly initialized with a <code>KeyStore</code> object or any
other parameters. For example, they may access trust material from
a local directory service via LDAP, use a remote online certificate
status checking server, or access default trust material from a
standard local location.</p>
<!-- *********************************************** -->
<h4><a name="CERTPATH" id="CERTPATH">PKIX TrustManager
Support</a></h4>
<p>The default trust manager algorithm is PKIX. It can be changed
by editing the <code>ssl.TrustManagerFactory.algorithm</code>
property in the <code>java.security</code> file.</p>
<p>The PKIX trust manager factory uses the <a href=
"../certpath/CertPathProgGuide.html">CertPath PKIX</a>
implementation from an installed security provider. The trust
manager factory can be initialized using the normal
<code>init(KeyStore ks)</code> method, or by passing CertPath
parameters to the the PKIX trust manager using the <a href=
"../../../../api/javax/net/ssl/CertPathTrustManagerParameters.html">
<code>javax.net.ssl.CertPathTrustManagerParameters</code></a>
class.</p>
<p>The following example illustrates how to get the trust manager
to use a particular LDAP certificate store and enable revocation
checking:</p>
<pre class="codeblock">
import javax.net.ssl.*;
import java.security.cert.*;
import java.security.KeyStore;
import java.io.FileInputStream;
...

// Obtain Keystore password
char[] pass = System.console().readPassword("Password: ");

// Create PKIX parameters
KeyStore anchors = KeyStore.getInstance("PKCS12");
anchors.load(new FileInputStream(anchorsFile, pass));
PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(anchors, new X509CertSelector());

// Specify LDAP certificate store to use
LDAPCertStoreParameters lcsp = new LDAPCertStoreParameters("ldap.imc.org", 389);
pkixParams.addCertStore(CertStore.getInstance("LDAP", lcsp));

// Specify that revocation checking is to be enabled
pkixParams.setRevocationEnabled(true);

// Wrap PKIX parameters as trust manager parameters
ManagerFactoryParameters trustParams = new CertPathTrustManagerParameters(pkixParams);

// Create TrustManagerFactory for PKIX-compliant trust managers
TrustManagerFactory factory = TrustManagerFactory.getInstance("PKIX");

// Pass parameters to factory to be passed to CertPath implementation
factory.init(trustParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, factory.getTrustManagers(), null);
</pre>
<p>If the <code>init(KeyStore ks)</code> method is used, then
default PKIX parameters are used with the exception that revocation
checking is disabled. It can be enabled by setting the
<code>com.sun.net.ssl.checkRevocation</code> system property to
<code>true</code>. This setting requires that the CertPath
implementation can locate revocation information by itself. The
PKIX implementation in the provider can do this in many cases but
requires that the system property
<code>com.sun.security.enableCRLDP</code> be set to
<code>true</code>.</p>
<p>For more information about PKIX and the CertPath API, see the
<a href="../certpath/CertPathProgGuide.html">Java PKI Programmer's
Guide</a>.</p>
<!-- *********************************************** -->
<h3><a name="X509TrustManager" id="X509TrustManager">The
X509TrustManager Interface</a></h3>
<p>The <code>javax.net.ssl.X509TrustManager</code> interface
extends the general <code>TrustManager</code> interface. It must be
implemented by a trust manager when using X.509-based
authentication.</p>
<p>To support X.509 authentication of remote socket peers through
JSSE, an instance of this interface must be passed to the
<code>init</code> method of an <code>SSLContext</code> object.</p>
<!-- *********************************************** -->
<h4>Creating an X509TrustManager</h4>
<p>You can either implement this interface directly yourself or
obtain one from a provider-based <code>TrustManagerFactory</code>
(such as that supplied by the <code>SunJSSE</code> provider). You could also
implement your own interface that delegates to a factory-generated
trust manager. For example, you might do this to filter the
resulting trust decisions and query an end-user through a graphical
user interface.</p>
<hr />
<p><strong>Note:</strong> If a null KeyStore parameter is passed to
the <code>SunJSSE</code> PKIX or SunX509 <code>TrustManagerFactory</code>, then
the factory uses the following process to try to find trust
material:</p>
<hr />
<ol>
<li>
<p>If the <code>javax.net.ssl.trustStore</code> property is
defined, then the <code>TrustManagerFactory</code> attempts to find
a file using the file name specified by that system property, and
uses that file for the KeyStore parameter. If the
<code>javax.net.ssl.trustStorePassword</code> system property is
also defined, then its value is used to check the integrity of the
data in the truststore before opening it.</p>
<p>If the <code>javax.net.ssl.trustStore</code> property is defined
but the specified file does not exist, then a default
<code>TrustManager</code> using an empty keystore is created.</p>
</li>
<li>If the <code>javax.net.ssl.trustStore</code> system property
was not specified, then:
<ul>
<li>if the file
<code><em>java-home</em>/lib/security/jssecacerts</code> exists,
that file is used;</li>
<li>if the file
<code><em>java-home</em>/lib/security/cacerts</code> exists, that
file is used;</li>
<li>if neither of these files exists, then the SSL cipher suite is
anonymous, does not perform any authentication, and thus does not
need a truststore.</li>
</ul>
</li>
</ol>

<p>The factory looks for a file specified via the
<code>javax.net.ssl.trustStore</code> Security Property or for the
<code>jssecacerts</code> file before checking for a <code>cacerts</code> file.
Therefore, you can provide a JSSE-specific set of trusted root
certificates separate from ones that might be present in cacerts
for code-signing purposes.</p>
<!-- *********************************************** -->
<h4><a name="OwnX509TM" id="OwnX509TM">Creating Your Own
X509TrustManager</a></h4>
<p>If the supplied <code>X509TrustManager</code> behavior is not
suitable for your situation, then you can create your own
<code>X509TrustManager</code> by either creating and registering
your own <code>TrustManagerFactory</code> or by implementing the
<code>X509TrustManager</code> interface directly.</p>
<p>The following example illustrates a
<code>MyX509TrustManager</code> class that enhances the default
<code>SunJSSE</code> <code>X509TrustManager</code> behavior by providing
alternative authentication logic when the default
<code>X509TrustManager</code> fails:</p>
<pre class="codeblock">
class MyX509TrustManager implements X509TrustManager {

/*
* The default PKIX X509TrustManager9.  Decisions are delegated
* to it, and a fall back to the logic in this class is performed
* if the default X509TrustManager does not trust it.
*/
X509TrustManager pkixTrustManager;

MyX509TrustManager() throws Exception {
// create a "default" JSSE X509TrustManager.

KeyStore ks = KeyStore.getInstance("PKCS12");
ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());

TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
tmf.init(ks);

TrustManager tms [] = tmf.getTrustManagers();

/*
* Iterate over the returned trust managers, looking
* for an instance of X509TrustManager.  If found,
* use that as the default trust manager.
*/
for (int i = 0; i &lt; tms.length; i++) {
if (tms[i] instanceof X509TrustManager) {
pkixTrustManager = (X509TrustManager) tms[i];
return;
}
}

/*
* Find some other way to initialize, or else the
* constructor fails.
*/
throw new Exception("Couldn't initialize");
}

/*
* Delegate to the default trust manager.
*/
public void checkClientTrusted(X509Certificate[] chain, String authType)
throws CertificateException {
try {
pkixTrustManager.checkClientTrusted(chain, authType);
} catch (CertificateException excep) {
// do any special handling here, or rethrow exception.
}
}

/*
* Delegate to the default trust manager.
*/
public void checkServerTrusted(X509Certificate[] chain, String authType)
throws CertificateException {
try {
pkixTrustManager.checkServerTrusted(chain, authType);
} catch (CertificateException excep) {
/*
* Possibly pop up a dialog box asking whether to trust the
* cert chain.
*/
}
}

/*
* Merely pass this through.
*/
public X509Certificate[] getAcceptedIssuers() {
return pkixTrustManager.getAcceptedIssuers();
}
}
</pre>
<p>Once you have created such a trust manager, assign it to an
<code>SSLContext</code> via the <code>init()</code> method, as in
the following example. Future <code>SocketFactories</code> created
from this <code>SSLContext</code> will use your new
<code>TrustManager</code> when making trust decisions.</p>
<pre class="codeblock">
TrustManager[] myTMs = new TrustManager[] { new MyX509TrustManager() };
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(null, myTMs, null);
</pre>
<!-- *********************************************** -->
<h4>Updating the Keystore Dynamically</h4>
<p>You can enhance <code>MyX509TrustManager</code> to handle
dynamic keystore updates. When a <code>checkClientTrusted</code> or
<code>checkServerTrusted</code> test fails and does not establish a
trusted certificate chain, you can add the required trusted
certificate to the keystore. You must create a new
<code>pkixTrustManager</code> from the
<code>TrustManagerFactory</code> initialized with the updated
keystore. When you establish a new connection (using the previously
initialized <code>SSLContext</code>), the newly added certificate
will be used when making trust decisions.</p>
<!-- *********************************************** -->
<h3><a name="X509ExtendedTrustManager" id=
"X509ExtendedTrustManager">X509ExtendedTrustManager Class</a></h3>
<p>The <code>X509ExtendedTrustManager</code> class is an abstract
implementation of the <code>X509TrustManager</code> interface. It
adds methods for connection-sensitive trust management. In
addition, it enables endpoint verification at the TLS layer.</p>
<p>In TLS 1.2 and later, both client and server can specify which
hash and signature algorithms they will accept. To authenticate the
remote side, authentication decisions must be based on both X509
certificates and the local accepted hash and signature algorithms.
The local accepted hash and signature algorithms can be obtained
using the
<code>ExtendedSSLSession.getLocalSupportedSignatureAlgorithms()</code>
method.</p>
<p>The <code>ExtendedSSLSession</code> object can be retrieved by
calling the <code>SSLSocket.getHandshakeSession()</code> method or
the <code>SSLEngine.getHandshakeSession()</code> method.</p>
<p>The <code>X509TrustManager</code> interface is not
connection-sensitive. It provides no way to access
<code>SSLSocket</code> or <code>SSLEngine</code> session
properties.</p>
<p>Besides TLS 1.2 support, the
<code>X509ExtendedTrustManager</code> class also supports algorithm
constraints and SSL layer host name verification. For JSSE
providers and trust manager implementations, the
<code>X509ExtendedTrustManager</code> class is highly recommended
over the legacy <code>X509TrustManager</code> interface.</p>
<!-- *********************************************** -->
<h4>Creating an X509ExtendedTrustManager</h4>
<p>You can either create an <code>X509ExtendedTrustManager</code>
subclass yourself (which is outlined in the following section) or
obtain one from a provider-based <code>TrustManagerFactory</code>
(such as that supplied by the <code>SunJSSE</code> provider). In Java SE 7, the
PKIX or SunX509 <code>TrustManagerFactory</code> returns an
<code>X509ExtendedTrustManager</code> instance.</p>
<!-- *********************************************** -->
<h4><a name="OwnX509ETM" id="OwnX509ETM">Creating Your Own
X509ExtendedTrustManager</a></h4>
<p>This section outlines how to create a subclass of
<code>X509ExtendedTrustManager</code> in nearly the same way as
described for <code>X509TrustManager</code>.</p>
<p>The following example illustrates how to create a class that
uses the PKIX <code>TrustManagerFactory</code> to locate a default
<code>X509ExtendedTrustManager</code> that will be used to make
decisions about trust. If the default trust manager fails for any
reason, then the subclass is can add other behavior. In the
example, these locations are indicated by comments in the
<code>catch</code> clauses.</p>
<pre class="codeblock">
import java.io.*;
import java.net.*;

import java.security.*;
import java.security.cert.*;
import javax.net.ssl.*;

public class MyX509ExtendedTrustManager extends X509ExtendedTrustManager {

/*
* The default PKIX X509ExtendedTrustManager.  Decisions are
* delegated to it, and a fall back to the logic in this class is
* performed if the default X509ExtendedTrustManager does not
* trust it.
*/
X509ExtendedTrustManager pkixTrustManager;

MyX509ExtendedTrustManager() throws Exception {
// create a &quot;default&quot; JSSE X509ExtendedTrustManager.

KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
ks.load(new FileInputStream(&quot;trustedCerts&quot;), &quot;passphrase&quot;.toCharArray());

TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;PKIX&quot;);
tmf.init(ks);

TrustManager tms [] = tmf.getTrustManagers();

/*
* Iterate over the returned trust managers, looking
* for an instance of X509ExtendedTrustManager. If found,
* use that as the default trust manager.
*/
for (int i = 0; i &lt; tms.length; i++) {
if (tms[i] instanceof X509ExtendedTrustManager) {
pkixTrustManager = (X509ExtendedTrustManager) tms[i];
return;
}
}

/*
* Find some other way to initialize, or else we have to fail the
* constructor.
*/
throw new Exception(&quot;Couldn't initialize&quot;);
}

/*
* Delegate to the default trust manager.
*/
public void checkClientTrusted(X509Certificate[] chain, String authType)
throws CertificateException {
try {
pkixTrustManager.checkClientTrusted(chain, authType);
} catch (CertificateException excep) {
// do any special handling here, or rethrow exception.
}
}

/*
* Delegate to the default trust manager.
*/
public void checkServerTrusted(X509Certificate[] chain, String authType)
throws CertificateException {
try {
pkixTrustManager.checkServerTrusted(chain, authType);
} catch (CertificateException excep) {
/*
* Possibly pop up a dialog box asking whether to trust the
* cert chain.
*/
}
}

/*
* Connection-sensitive verification.
*/
public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)
throws CertificateException {
try {
pkixTrustManager.checkClientTrusted(chain, authType, socket);
} catch (CertificateException excep) {
// do any special handling here, or rethrow exception.
}
}

public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
throws CertificateException {
try {
pkixTrustManager.checkClientTrusted(chain, authType, engine);
} catch (CertificateException excep) {
// do any special handling here, or rethrow exception.
}
}

public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)
throws CertificateException {
try {
pkixTrustManager.checkServerTrusted(chain, authType, socket);
} catch (CertificateException excep) {
// do any special handling here, or rethrow exception.
}
}

public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
throws CertificateException {
try {
pkixTrustManager.checkServerTrusted(chain, authType, engine);
} catch (CertificateException excep) {
// do any special handling here, or rethrow exception.
}
}

/*
* Merely pass this through.
*/
public X509Certificate[] getAcceptedIssuers() {
return pkixTrustManager.getAcceptedIssuers();
}
}
</pre>
<!-- *********************************************** -->
<h3><a name="KeyManager" id="KeyManager">The KeyManager
Interface</a></h3>
<p>The primary responsibility of the <code>KeyManager</code> is to
select the authentication credentials that will eventually be sent
to the remote host. To authenticate yourself (a local secure socket
peer) to a remote peer, you must initialize an
<code>SSLContext</code> object with one or more
<code>KeyManager</code> objects. You must pass one
<code>KeyManager</code> for each different authentication mechanism
that will be supported. If null is passed into the
<code>SSLContext</code> initialization, then an empty
<code>KeyManager</code> will be created. If the internal default
context is used (for example, an <code>SSLContext</code> created by
<code>SSLSocketFactory.getDefault()</code> or
<code>SSLServerSocketFactory.getDefault()</code>), then a <a href=
"#CustomizingStores">default <code>KeyManager</code></a> is
created. Typically, a single key manager supports authentication
based on X.509 public key certificates. Some secure socket
implementations may also support authentication based on shared
secret keys, Kerberos, or other mechanisms.</p>
<p><code>KeyManager</code> objects are created either by a
<code>KeyManagerFactory</code>, or by providing a concrete
implementation of the interface.</p>
<!-- *********************************************** -->
<h3><a name="KeyManagerFactory" id="KeyManagerFactory">The
KeyManagerFactory Class</a></h3>
<p>The <code>javax.net.ssl.KeyManagerFactory</code> class is an
engine class for a provider-based service that acts as a factory
for one or more types of <code>KeyManager</code> objects. The
<code>SunJSSE</code> provider implements a factory that can return a basic X.509
key manager. Because it is provider-based, additional factories can
be implemented and configured to provide additional or alternative
key managers.</p>
<!-- *********************************************** -->
<h4>Creating a KeyManagerFactory</h4>
<p>You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name
string instead of a protocol name to the <code>getInstance()</code>
method:</p>
<pre class="codeblock">
KeyManagerFactory kmf = getInstance(String algorithm);

KeyManagerFactory kmf = getInstance(String algorithm, String provider);

KeyManagerFactory kmf = getInstance(String algorithm, Provider provider);
</pre>
<p>A sample call as follows:</p>
<pre class="codeblock">
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509", "SunJSSE");
</pre>
<p>The preceding call creates an instance of the <code>SunJSSE</code> provider's
default key manager factory, which provides basic X.509-based
authentication keys.</p>
<p>A newly created factory should be initialized by calling one of
the <code>init</code> methods:</p>
<pre class="codeblock">
public void init(KeyStore ks, char[] password);
public void init(ManagerFactoryParameters spec);
</pre>
<p>Call whichever <code>init</code> method is appropriate for the
<code>KeyManagerFactory</code> you are using. If you are not sure,
then ask the provider vendor.</p>
<p>For many factories, such as the default SunX509
<code>KeyManagerFactory</code> from the <code>SunJSSE</code> provider, the
<code>KeyStore</code> and password are the only information
required to initialize the <code>KeyManagerFactory</code> and thus
the first <code>init</code> method is the appropriate one to call.
The <code>KeyManagerFactory</code> will query the
<code>KeyStore</code> for information about which private key and
matching public key certificates should be used for authenticating
to a remote socket peer. The password parameter specifies the
password that will be used with the methods for accessing keys from
the <code>KeyStore</code>. All keys in the <code>KeyStore</code>
must be protected by the same password.</p>
<p>Sometimes initialization parameters other than a
<code>KeyStore</code> and password are needed by a provider. Users
of that provider are expected to pass an implementation of the
appropriate <code>ManagerFactoryParameters</code> as defined by the
provider. The provider can then call the specified methods in the
<code>ManagerFactoryParameters</code> implementation to obtain the
needed information.</p>
<p>Some factories can provide access to authentication material
without being initialized with a <code>KeyStore</code> object or
any other parameters. For example, they may access key material as
part of a login mechanism such as one based on JAAS, the Java
Authentication and Authorization Service.</p>
<p>As previously indicated, the <code>SunJSSE</code> provider supports a SunX509
factory that must be initialized with a <code>KeyStore</code>
parameter.</p>
<!-- *********************************************** -->
<h3><a name="X509KeyManager" id="X509KeyManager">The X509KeyManager
Interface</a></h3>
<p>The <code>javax.net.ssl.X509KeyManager</code> interface extends
the general <code>KeyManager</code> interface. It must be
implemented by a key manager for X.509-based authentication. To
support X.509 authentication to remote socket peers through JSSE,
an instance of this interface must be passed to the
<code>init()</code> method of an <code>SSLContext</code>
object.</p>
<!-- *********************************************** -->
<h4>Creating an X509KeyManager</h4>
<p>You can either implement this interface directly yourself or
obtain one from a provider-based <code>KeyManagerFactory</code>
(such as that supplied by the <code>SunJSSE</code> provider). You could also
implement your own interface that delegates to a factory-generated
key manager. For example, you might do this to filter the resulting
keys and query an end-user through a graphical user interface.</p>
<!-- *********************************************** -->
<h4>Creating Your Own X509KeyManager</h4>
<p>If the default <code>X509KeyManager</code> behavior is not
suitable for your situation, then you can create your own
<code>X509KeyManager</code> in a way similar to that shown in
<a href="#OwnX509TM">Creating Your Own X509TrustManager</a>.</p>
<!-- *********************************************** -->
<h3><a name="X509ExtendedKeyManager" id=
"X509ExtendedKeyManager">The X509ExtendedKeyManager Class</a></h3>
<p>The <code>X509ExtendedKeyManager</code> abstract class is an
implementation of the <code>X509KeyManager</code> interface that
allows for connection-specific key selection. It adds two methods
that select a key alias for client or server based on the key type,
allowed issuers, and current <code>SSLEngine</code>:</p>
<ul>
<li><code>public String chooseEngineClientAlias(String[] keyType,
Principal[] issuers, SSLEngine engine)</code></li>
<li><code>public String chooseEngineServerAlias(String keyType,
Principal[] issuers, SSLEngine engine)</code></li>
</ul>
<p>If a key manager is not an instance of the
<code>X509ExtendedKeyManager</code> class, then it will not work
with the <code>SSLEngine</code> class.</p>
<p>For JSSE providers and key manager implementations, the
<code>X509ExtendedKeyManager</code> class is highly recommended
over the legacy <code>X509KeyManager</code> interface.</p>
<p>In TLS 1.2 and later, both client and server can specify which
hash and signature algorithms they will accept. To pass the
authentication required by the remote side, local key selection
decisions must be based on both X509 certificates and the remote
accepted hash and signature algorithms. The remote accepted hash
and signature algorithms can be retrieved using the
<code>ExtendedSSLSession.getPeerSupportedSignatureAlgorithms()</code>
method.</p>
<p>You can create your own <code>X509ExtendedKeyManager</code>
subclass in a way similar to that shown in <a href=
"#OwnX509ETM">Creating Your Own X509ExtendedTrustManager</a>.</p>
<p>Support for the <a href="#SNIExtension">Server Name Indication
(SNI)</a> extension on the server side enables the key manager to
check the server name and select the appropriate key accordingly.
For example, suppose there are three key entries with certificates
in the keystore:</p>
<ul>
<li><code>cn=www.example.com</code></li>
<li><code>cn=www.example.org</code></li>
<li><code>cn=www.example.net</code></li>
</ul>
<p>If the ClientHello message requests to connect to
<code>www.example.net</code> in the SNI extension, then the server
should be able to select the certificate with subject
<code>cn=www.example.net</code>.</p>
<!-- *********************************************** -->
<h3><a name="RelsTM_KM" id="RelsTM_KM">Relationship Between a
TrustManager and a KeyManager</a></h3>
<p>Historically, there has been confusion regarding the
functionality of a <code>TrustManager</code> and a
<code>KeyManager</code>.</p>
<p>A <code>TrustManager</code> determines whether the remote
authentication credentials (and thus the connection) should be
trusted.</p>
<p>A <code>KeyManager</code> determines which authentication
credentials to send to the remote host.</p>
<!-- *********************************************** -->
<h2><a name="SecondarySupportClasses" id=
"SecondarySupportClasses">Secondary Support Classes and
Interfaces</a></h2>
<p>These classes are provided as part of the JSSE API to support
the creation, use, and management of secure sockets. They are less
likely to be used by secure socket applications than are the core
and support classes. The secondary support classes and interfaces
are part of the <code>javax.net.ssl</code> and
<code>javax.security.cert</code> packages.</p>
<!-- *********************************************** -->
<h3><a name="SSLParameters" id="SSLParameters">The SSLParameters
Class</a></h3>
<p>The <code>SSLParameters</code> class encapsulates the following
parameters that affect a TLS connection:</p>
<ul>
<li>The list of cipher suites to be accepted in an SSL/TLS
handshake</li>
<li>The list of protocols to be allowed</li>
<li>The endpoint identification algorithm during SSL/TLS
handshaking</li>
<li>The server names and server name matchers (see the <a href=
"#SNIExtension">Server Name Indication (SNI) Extension</a>)</li>
<li>The algorithm constraints</li>
<li>Whether SSL/TLS servers should request or require client
authentication</li>
<li>The cipher suite preference to be used in an SSL/TLS
handshake</li>
</ul>
<p>You can retrieve the current <code>SSLParameters</code> for an
<code>SSLSocket</code> or <code>SSLEngine</code> by using the
following methods:</p>
<ul>
<li><code>getSSLParameters()</code> in an <code>SSLSocket</code>,
<code>SSLServerSocket</code>, and <code>SSLEngine</code></li>
<li><code>getDefaultSSLParameters()</code> and
<code>getSupportedSSLParamters()</code> in an
<code>SSLContext</code></li>
</ul>
<p>You can assign <code>SSLParameters</code> with the
<code>setSSLParameters()</code> method in an
<code>SSLSocket</code>, <code>SSLServerSocket</code> and
<code>SSLEngine</code>.</p>
<p>You can explicitly set the server name indication with the
<code>SSLParameters.setServerNames()</code> method. The server name
indication in client mode also affects endpoint identification. In
the implementation of <code>X509ExtendedTrustManager</code>, it
uses the server name indication retrieved by the
<code>ExtendedSSLSession.getRequestedServerNames()</code> method.
The following example illustrates this functionality:</p>
<pre class="codeblock">
SSLSocketFactory factory = ...
SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
// SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);

SSLParameters params = sslSocket.getSSLParameters();
params.setServerNames(serverNames);
sslSocket.setSSLParameters(params);
// sslEngine.setSSLParameters(params);
</pre>
<p>In the preceding example, the host name in the server name
indication (<code>www.example.com</code>) will be used to make
endpoint identification against the peer's identity presented in
the end-entity's X.509 certificate.</p>
<h4><a name="cipher_suite_preference" id=
"cipher_suite_preference">Cipher Suite Preference</a></h4>
<p>During TLS handshaking, the client requests to negotiate a
cipher suite from a list of cryptographic options that it supports,
starting with its first preference. Then, the server selects a
single cipher suite from the list of cipher suites requested by the
client. The selection honors the server's preference by default, which is the
most secure setting. However, the server can choose to honor the client's
preference rather than its own preference by invoking the method
<code>SSLParameters.setUseCipherSuitesOrder(false)</code>.</p>
<!-- *********************************************** -->
<h3><a name="SSLSessionContext" id="SSLSessionContext">The
SSLSessionContext Interface</a></h3>
<p>The <code>javax.net.ssl.SSLSessionContext</code> interface is a
grouping of <a href="#SSLSession"><code>SSLSession</code></a>
objects associated with a single entity. For example, it could be
associated with a server or client that participates in many
sessions concurrently. The methods in this interface enable the
enumeration of all sessions in a context and allow lookup of
specific sessions via their session IDs.</p>
<p>An <code>SSLSessionContext</code> may optionally be obtained
from an <code>SSLSession</code> by calling the SSLSession
<code>getSessionContext()</code> method. The context may be
unavailable in some environments, in which case the
<code>getSessionContext()</code> method returns null.</p>
<!-- *********************************************** -->
<h3><a name="SSLSessionBindingListener" id=
"SSLSessionBindingListener">The SSLSessionBindingListener
Interface</a></h3>
<p>The <code>javax.net.ssl.SSLSessionBindingListener</code>
interface is implemented by objects that are notified when they are
being bound or unbound from an <a href=
"#SSLSession"><code>SSLSession</code></a>.</p>
<!-- *********************************************** -->
<h3><a name="SSLSessionBindingEvent" id=
"SSLSessionBindingEvent">The SSLSessionBindingEvent Class</a></h3>
<p>The <code>javax.net.ssl.SSLSessionBindingEvent</code> class
defines the event communicated to an <a href=
"#SSLSessionBindingListener"><code>SSLSessionBindingListener</code></a>
when it is bound or unbound from an <a href=
"#SSLSession"><code>SSLSession</code></a>.</p>
<!-- *********************************************** -->
<h3><a name="HandShakeCompletedListener" id=
"HandShakeCompletedListener">The HandShakeCompletedListener
Interface</a></h3>
<p>The <code>javax.net.ssl.HandShakeCompletedListener</code>
interface is an interface implemented by any class that is notified
of the completion of an SSL protocol handshake on a given
<code>SSLSocket</code> connection.</p>
<!-- *********************************************** -->
<h3><a name="HandShakeCompletedEvent" id=
"HandShakeCompletedEvent">The HandShakeCompletedEvent
Class</a></h3>
<p>The <code>javax.net.ssl.HandShakeCompletedEvent</code> class
define the event communicated to a <a href=
"#HandShakeCompletedListener"><code>HandShakeCompletedListener</code></a>
upon completion of an SSL protocol handshake on a given
<code>SSLSocket</code> connection.</p>
<!-- *********************************************** -->
<h3><a name="HostnameVerifier" id="HostnameVerifier">The
HostnameVerifier Interface</a></h3>
<p>If the SSL/TLS implementation's standard host name verification
logic fails, then the implementation calls the
<code>verify()</code> method of the class that implements this
interface and is assigned to this <code>HttpsURLConnection</code>
instance. If the callback class can determine that the host name is
acceptable given the parameters, it reports that the connection
should be allowed. An unacceptable response causes the connection
to be terminated.</p>
<p>For example:</p>
<pre class="codeblock">
public class MyHostnameVerifier implements HostnameVerifier {

public boolean verify(String hostname, SSLSession session) {
// pop up an interactive dialog box
// or insert additional matching logic
if (good_address) {
return true;
} else {
return false;
}
}
}

//...deleted...

HttpsURLConnection urlc = (HttpsURLConnection)
(new URL("https://www.example.com/")).openConnection();
urlc.setHostnameVerifier(new MyHostnameVerifier());
</pre>
<p>See <a href="#HttpsURLConnection">The HttpsURLConnection
Class</a> for more information about how to assign the
<code>HostnameVerifier</code> to the
<code>HttpsURLConnection</code>.</p>
<!-- *********************************************** -->
<h3><a name="X509Certificate" id="X509Certificate">The
X509Certificate Class</a></h3>
<p>Many secure socket protocols perform authentication using public
key certificates, also called X.509 certificates. This is the
default authentication mechanism for the SSL/TLS protocols.</p>
<p>The <code>java.security.cert.X509Certificate</code> abstract
class provides a standard way to access the attributes of X.509
certificates.</p>
<hr />
<p><strong>Note:</strong> The
<code>javax.security.cert.X509Certificate</code> class is supported
only for backward compatibility with previous (1.0.x and 1.1.x)
versions of JSSE. New applications should use the
<code>java.security.cert.X509Certificate</code> class instead.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="AlgorithmConstraints" id="AlgorithmConstraints">The
AlgorithmConstraints Interface</a></h3>
<p>The <code>java.security.AlgorithmConstraints</code> interface is
used for controlling allowed cryptographic algorithms.
<code>AlgorithmConstraints</code> defines three
<code>permits()</code> methods. These methods tell whether an
algorithm name or a key is permitted for certain cryptographic
functions. Cryptographic functions are represented by a set of
<code>CryptoPrimitive</code>, which is an enumeration containing
fields like <code>STREAM_CIPHER</code>,
<code>MESSAGE_DIGEST</code>, and <code>SIGNATURE</code>.</p>
<p>Thus, an <code>AlgorithmConstraints</code> implementation can
answer questions like: Can I use this key with this algorithm for
the purpose of a cryptographic operation?</p>
<p>An <code>AlgorithmConstraints</code> object can be associated
with an <code>SSLParameters</code> object by using the new
<code>setAlgorithmConstraints()</code> method. The current
<code>AlgorithmConstraints</code> object for an
<code>SSLParameters</code> object is retrieved using the
<code>getAlgorithmConstraints()</code> method.</p>
<!-- *********************************************** -->
<h3><a name="StandardConstants" id="StandardConstants">The
StandardConstants Class</a></h3>
<p>The <code>StandardConstants</code> class is used to represent
standard constants definitions in JSSE.</p>
<p><code>StandardConstants.SNI_HOST_NAME</code> represents a domain
name server (DNS) host name in a <a href="#SNIExtension">Server
Name Indication (SNI)</a> extension, which can be used when
instantiating an <code>SNIServerName</code> or
<code>SNIMatcher</code> object.</p>
<!-- *********************************************** -->
<h3><a name="SNIServerName" id="SNIServerName">The SNIServerName
Class</a></h3>
<p>An instance of the abstract <code>SNIServerName</code> class
represents a server name in the <a href="#SNIExtension">Server Name
Indication (SNI)</a> extension. It is instantiated using the type
and encoded value of the specified server name.</p>
<p>You can use the <code>getType()</code> and
<code>getEncoded()</code> methods to return the server name type
and a copy of the encoded server name value, respectively. The
<code>equals()</code> method can be used to check if some other
object is "equal" to this server name. The <code>hashCode()</code>
method returns a hash code value for this server name. To get a
string representation of the server name (including the server name
type and encoded server name value), use the
<code>toString()</code> method.</p>
<!-- *********************************************** -->
<h3><a name="SNIMatcher" id="SNIMatcher">The SNIMatcher
Class</a></h3>
<p>An instance of the abstract <code>SNIMatcher</code> class
performs match operations on an <code>SNIServerName</code> object.
Servers can use information from the <a href="#SNIExtension">Server
Name Indication (SNI)</a> extension to decide if a specific
<code>SSLSocket</code> or <code>SSLEngine</code> should accept a
connection. For example, when multiple "virtual" or "name-based"
servers are hosted on a single underlying network address, the
server application can use SNI information to determine whether
this server is the exact server that the client wants to access.
Instances of this class can be used by a server to verify the
acceptable server names of a particular type, such as host
names.</p>
<p>The <code>SNIMatcher</code> class is instantiated using the
specified server name type on which match operations will be
performed. To match a given <code>SNIServerName</code>, use the
<code>matches()</code> method. To return the server name type of
the given <code>SNIMatcher</code> object, use the
<code>getType()</code> method.</p>
<!-- *********************************************** -->
<h3><a name="SNIHostName" id="SNIHostName">The SNIHostName
Class</a></h3>
<p>An instance of the <code>SNIHostName</code> class (which extends
the <code>SNIServerName</code> class) represents a server name of
type "host_name" (see <a href="#StandardConstants">The
StandardConstants Class</a>) in the <a href="#SNIExtension">Server
Name Indication (SNI)</a> extension. To instantiate an
<code>SNIHostName</code>, specify the fully qualified DNS host name
of the server (as understood by the client) as a
<code>String</code> argument. The argument is illegal in the
following cases:</p>
<ul>
<li>The argument is empty.</li>
<li>The argument ends with a trailing period.</li>
<li>The argument is not a valid Internationalized Domain Name (IDN)
compliant with the RFC 3490 specification.</li>
</ul>
<p>You can also instantiate an <code>SNIHostName</code> by
specifying the encoded host name value as a byte array. This method
is typically used to parse the encoded name value in a requested
SNI extension. Otherwise, use the <code>SNIHostName(String
hostname)</code> constructor. The <code>encoded</code> argument is
illegal in the following cases:</p>
<ul>
<li>The argument is empty.</li>
<li>The argument ends with a trailing period.</li>
<li>The argument is not a valid Internationalized Domain Name (IDN)
compliant with the RFC 3490 specification.</li>
<li>The argument is not encoded in UTF-8 or US-ASCII.</li>
</ul>
<hr />
<p><strong>Note:</strong> The <code>encoded</code> byte array
passed in as an argument is cloned to protect against subsequent
modification.</p>
<hr />
<p>To return the host name of an <code>SNIHostName</code> object in
US-ASCII encoding, use the <code>getAsciiName()</code> method. To
compare a server name to another object, use the
<code>equals()</code> method (comparison is <em>not</em>
case-sensitive). To return a hash code value of an
<code>SNIHostName</code>, use the <code>hashCode()</code> method.
To return a string representation of an <code>SNIHostName</code>,
including the DNS host name, use the <code>toString()</code>
method.</p>
<p>You can create an <code>SNIMatcher</code> object for an
<code>SNIHostName</code> object by passing a regular expression
representing one or more host names to match to the
<code>createSNIMatcher()</code> method.</p>
<!-- *********************************************** -->
<a name="Customization" id="Customization"></a>
<h2><a name="InstallationAndCustomization" id=
"InstallationAndCustomization">Customizing JSSE</a></h2>

<p>JSSE includes a standard implementation that can be customized
by plugging in different implementations or specifying the default
keystore, and so on. The following tables summarize which
aspects can be customized, what the defaults are, and which
mechanisms are used to provide customization.</p>

<p>Some of the customizations are done by setting Security Property
or system property values. Sections following the table explain
how to set such property values.</p>

<p>The following table shows items that are customized by setting a <code>java.security.Security</code> property:</p>

<table border="1" cellspacing="0" summary="Security Properties and customized items">
<tr>
<th id="h101">Security Property</th>
<th id="h102">Customized Item</th>
<th id="h103">Default Value</th>
<th id="h104">Notes</th>
</tr>
<tr>
<td headers="h101"><code>cert.provider.x509v1</code></td>
<td headers="h102"><a href="#X509CCust">Customizing the X509Certificate Implementation</a></td>
<td headers="h103">X509Certificate implementation from Oracle</td>
<td headers="h104">None</td>
</tr>
<tr>
<td headers="h101">JCE encryption algorithms used by the <code>SunJSSE</code> provider</td>
<td headers="h102">Give alternative JCE algorithm providers a higher preference order
than the SunJCE provider; see <a href="#JCECust">Customizing the Encryption
Algorithm Providers</a>.</td>
<td headers="h103">SunJCE implementations</td>
<td headers="h104">None</td>
</tr>
<tr>
<td headers="h101"><code>jdk.certpath.disabledAlgorithms</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102">Disabled certificate verification cryptographic algorithm (see
<a href="#DisabledAlgorithms">Disabled and Restricted Cryptographic Algorithms</a>)</td>
<td headers="h103">MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224, include jdk.disabled.namedCurves, SHA1 usage SignedJAR &amp; denyAfter 2019-01-01<a href="#legacy-algorithms-note"><sup>2</sup></a></td>
<td headers="h104">None</td>
</tr>
<tr>
<td headers="h101"><code>jdk.tls.disabledAlgorithms</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102"><a href="#DisabledAlgorithms">Disabled and Restricted Cryptographic Algorithms</a></td>
<td headers="h103">SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, include jdk.disabled.namedCurves<a href="#legacy-algorithms-note"><sup>2</sup></a></td>
<td headers="h104">Disables specific algorithms (protocols versions, cipher suites,
key exchange mechanisms, etc.) that will not be negotiated for
TLS connections, even if they are enabled explicitly in an
application</td>
</tr>
<tr>
<td headers="h101"><code>jdk.tls.keyLimits</code><a href="#jsse-impl-security-property"><sup>1</sup></a> (since JDK 8u261)</td>
<td headers="h102"><a href="#limit-data-encrypted">Limiting Amount of Data Algorithms May Encrypt with a Set of Keys</a></td>
<td headers="h103">AES/GCM/NoPadding KeyUpdate 2^37</td>
<td headers="h104">Limits the amount of data an algorithm may encrypt with a specific
set of keys; once this limit is reached, a KeyUpdate post-handshake
message is sent, which requests that the current set of keys be
updated.</td>
</tr>
<tr>
<td headers="h101"><code>jdk.tls.legacyAlgorithms</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102"><a href="#LegacyAlgorithms">Legacy Cryptographic Algorithms</a></td>
<td headers="h103">K_NULL, C_NULL, M_NULL, DH_anon, ECDH_anon, RC4_128, RC4_40, DES_CBC, DES40_CBC, 3DES_EDE_CBC<a href="#legacy-algorithms-note"><sup>2</sup></a></td>
<td headers="h104">Specifies which algorithms are considered legacy algorithms, which
are not negotiated during TLS security parameters negotiation
unless there are no other candidates.</td>
</tr>
<tr>
<td headers="h101"><code>jdk.tls.maxCertificateChainLength</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102">Certificate chain handling</td>
<td headers="h103">10</td>
<td headers="h104">Specifies the maximum allowed length of the certificate chain in TLS handshaking.</td>
</tr>
<tr>
<td headers="h101"><code>jdk.tls.maxHandshakeMessageSize</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102">Certificate chain handling</td>
<td headers="h103">32768 (32 kilobytes)</td>
<td headers="h104">Specifies the maximum allowed size, in bytes, for the handshake message in TLS handshaking.</td>
</tr>
<tr>
<td headers="h101"><code>jdk.tls.server.defaultDHEParameters</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102">Diffie-Hellman groups</td>
<td headers="h103">Safe prime Diffie-Hellman groups in JDK TLS implementation</td>
<td headers="h104">Defines default finite field Diffie-Hellman ephemeral (DHE)
parameters for Transport Layer Security (TLS) processing</td>
</tr>
<tr>
<td headers="h101"><code>ocsp.enable</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102"><a href="ocsp.html">Client-Driven OCSP and OCSP Stapling</a></td>
<td headers="h103">false</td>
<td headers="h104">Enables client-driven Online Certificate Status Protocol (OCSP).
You must also enable revocation checking; see
<a href="ocsp.html#setting-up-a-java-client-to-use-client-driven-ocsp">Setting up a Java Client to use Client-Driven OCSP</a>. </td>
</tr>
<tr>
<td headers="h101"><code>security.provider.<em>n</em></code></td>
<td headers="h102">Cryptographic service provider; see <a href="#ProviderCust">Customizing the
Provider Implementation</a> and <a href="#JCECust">Customizing the Encryption
Algorithm Providers</a></td>
<td headers="h103">Differs per platform; check the <code>java.security</code> Security Properties file.</td>   
<td headers="h104">Specify the provider in the <code>security.provider.<em>n</em>=</code>
line in the Security Properties file, where <code><em>n</em></code> is an
integer whose value is equal or greater than 1.</td>
</tr>
<tr>
<td headers="h101"><code>ssl.KeyManagerFactory.algorithm</code></td>
<td headers="h102">Default key manager factory algorithm name
(see <a href="#DefaultKTMCust">Customizing the
Default Key Managers and Trust Managers</a>) </td>
<td headers="h103">SunX509</td>
<td headers="h104">None</td>
</tr>
<tr>
<td headers="h101"><code>ssl.ServerSocketFactory.provider</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102">Default <code>SSLServerSocketFactory</code> implementation </td>
<td headers="h103"><code>SSLServerSocketFactory</code> implementation from Oracle </td>
<td headers="h104">None</td>
</tr>
<tr>
<td headers="h101"><code>ssl.SocketFactory.provider</code><a href="#jsse-impl-security-property"><sup>1</sup></a></td>
<td headers="h102">Default <code>SSLSocketFactory</code> implementation </td>
<td headers="h103"><code>SSLSocketFactory</code> implementation from Oracle </td>
<td headers="h104">None</td>
</tr>
<tr>
<td headers="h101"><code>ssl.TrustManagerFactory.algorithm</code></td>
<td headers="h102">Default trust manager factory algorithm name
(see <a href="#DefaultKTMCust">Customizing the
Default Key Managers and Trust Managers</a>)</td>
<td headers="h103">PKIX</td>
<td headers="h104">None</td>
</tr>
</table>


<p><a name="jsse-impl-security-property"><sup>1</sup></a>This Security Property is
currently used by the JSSE implementation, but it is not guaranteed to be
examined and used by other implementations. If it is examined by another
implementation, then that implementation should handle it in the same manner
as the JSSE implementation does. There is no guarantee the property will
continue to exist or be of the same type (system or Security) in future
releases.</p>

<p><a name="legacy-algorithms-note"><sup>2</sup></a>The list of restricted,
disabled, and legacy algorithms specified in these Security Properties may
change; see the <code>java.security</code> file in your JDK installation
for the latest values.</p> 

<!-- ****************************************************** -->

<p>The following table shows items that are customized by setting a <code>java.lang.System</code> property.</p>

<table border="1" cellspacing="0" summary="System properties and customized items">
<tr>
<th id="h201">System Property</th>
<th id="h202">Customized Item</th>
<th id="h203">Default</th>
<th id="h204">Notes</th>
</tr>
<tr>
<td headers="h201"><code>com.sun.net.ssl.checkRevocation</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Revocation checking</td>
<td headers="h203">false</td>
<td headers="h204">You must enable revocation checking to enable client-driven OCSP;
see <a href="ocsp.html">Client-Driven OCSP and OCSP Stapling</a>.</td>
</tr>
<tr>
<td headers="h201">Customize via port field in the HTTPS URL*</td>
<td headers="h202">Default HTTPS port</td>
<td headers="h203">443</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>https.cipherSuites</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default cipher suites for HTTPS connections<a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h203">Determined by the socket factory.</td>
<td headers="h204">This contains a comma-separated list of cipher suite names
specifying which cipher suites to enable for use on this
<code>HttpsURLConnection</code>. See the <code>SSLSocket.setEnabledCipherSuites(String[])</code>
method. Note that this method sets the preference order of the
ClientHello cipher suites directly from the String array passed to it.</td>
</tr>
<tr>
<td headers="h201"><a name="https_protocols"/><code>https.protocols</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default handshaking protocols for HTTPS connections.</td>
<td headers="h203">Determined by the socket factory.</td>
<td headers="h204">This contains a comma-separated list of protocol suite names
specifying which protocol suites to enable on this <code>HttpsURLConnection</code>.
See <code>SSLSocket.setEnabledProtocols(String[])</code>.</td>
</tr>
<tr>
<td headers="h201"><code>https.proxyHost</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default proxy host</td>
<td headers="h203">None</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>https.proxyPort</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default proxy port</td>
<td headers="h203">80</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>java.protocol.handler.pkgs</code></td>
<td headers="h202"><a href="#HTTPSCust">Specifying an Alternative
HTTPS Protocol Implementation</a></td>
<td headers="h203">Implementation from Oracle</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.keyStore</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default keystore; see <a href="#CustomizingStores">Customizing
the Default Keystores and Truststores, Store Types, and Store
Passwords</a></td>
<td headers="h203"><code>NONE</code></td>
<td headers="h204">The value <code>NONE</code> may be specified. This setting is appropriate if
the keystore is not file-based (for example, it resides in a hardware
token).</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.keyStorePassword</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default keystore password; see <a href="#CustomizingStores">Customizing
the Default Keystores and Truststores, Store Types, and Store
Passwords</a></td>
<td headers="h203">None</td>
<td headers="h204">It is inadvisable to specify the password in a way that exposes it
to discovery by other users. For example, specifying the password on the
command line. To keep the password secure, have the application prompt
for the password, or specify the password in a properly protected option
file.</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.keyStoreProvider</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default keystore provider; see <a href="#CustomizingStores">Customizing
the Default Keystores and Truststores, Store Types, and Store
Passwords</a></td>
<td headers="h203">None</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.keyStoreType</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default keystore type; see <a href="#CustomizingStores">Customizing
the Default Keystores and Truststores, Store Types, and Store
Passwords</a></td>
<td headers="h203"><code>KeyStore.getDefaultType()</code></td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.sessionCacheSize</code> (since JDK 8u261)</td>
<td headers="h202">Default value for the maximum number of entries in the SSL session
cache</td>
<td headers="h203">20480</td>
<td headers="h204">The session cache size can be set by calling the
<code>SSLSessionContext.setSessionCacheSize</code> method or by setting the
<code>javax.net.ssl.sessionCachSize</code> system property. If the cache size is
not set, the default value is used. </td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.trustStore</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default truststore; see
<a href="#CustomizingStores">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
<td headers="h203"><code>jssecacerts</code>, if it exists; otherwise, <code>cacerts</code></td>
<td headers="h204">The value <code>NONE</code> may be specified. This setting is appropriate if
the truststore is not file-based (for example, it resides in a
hardware token).</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.trustStorePassword</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default truststore password; see
<a href="#CustomizingStores">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
<td headers="h203">None</td>
<td headers="h204">It is inadvisable to specify the password in a way that exposes it
to discovery by other users. For example, specifying the password on
the command line. To keep the password secure, have the application
prompt for the password, or specify the password in a properly
protected option file.</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.trustStoreProvider</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default truststore provider; see
<a href="#CustomizingStores">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
<td headers="h203">None</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>javax.net.ssl.trustStoreType</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default truststore type; see
<a href="#CustomizingStores">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></td>
<td headers="h203"><code>KeyStore.getDefaultType()</code></td>
<td headers="h204">None</td>  
</tr>
<tr>
<td headers="h201"><code>jdk.tls.acknowledgeCloseNotify</code><a href="#jsse-impl-system-property"><sup>1</sup></a> (since JDK 8u261)</td>
<td headers="h202"><a href="#acknowledge-close-notify-alert">Specifying that close_notify Alert Is Sent When One Is Received</a></td>
<td headers="h203">false</td>
<td headers="h204">If the system property is set to true, then when the client or
server receives a close_notify alert, it sends a corresponding
close_notify alert and the connection is duplex closed.</td>
</tr>


<tr>
<td headers="h201"><code>jdk.tls.client.cipherSuites</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Client-side default enabled cipher suites; see <a href="#default-enabled-cipher-suites">Specifying Default Enabled Cipher Suites</a>.</td>
<td headers="h203">See
<a href="../SunProviders.html#SupportedCipherSuites">SunJSSE Cipher Suites</a> for a list of currently implemented
<code>SunJSSE</code> cipher suites for this JDK release, sorted by order of
preference.</td>
<td headers="h204"><strong>Caution</strong>: These system properties can be used to configure weak
cipher suites, or the configured cipher suites may be weak in the
future. It is not recommended that you use these system properties
without understanding the risks. </td>
</tr>

<tr>
  <td headers="h201"><code>jdk.tls.client.disableExtensions</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
  <td headers="h202"><a href="#ConfiguringDefaultExtensions">Configuring Default Extensions</a></td>
  <td headers="h203">None</td>
  <td headers="h204">Blocks extensions used on the client side.</td>
</tr>







<tr>
<td headers="h201"><a name="jdk_tls_client_protocols"/><code>jdk.tls.client.protocols</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default handshaking protocols for TLS clients. See
<a href="../SunProviders.html#SunJSSEProvider">The SunJSSE Provider</a>.</td>
<td headers="h203">None</td>
<td headers="h204">To enable specific <code>SunJSSE</code> protocols on the client, specify them
in a comma-separated list within quotation marks; all other supported
protocols are not enabled on the client. For example,
if <code>jdk.tls.client.protocols="TLSv1,TLSv1.1"</code>, then the
default protocol settings on the client for TLSv1 and TLSv1.1 are
enabled, while SSLv3, TLSv1.2, TLSv1.3, and SSLv2Hello are not
enabled.</td>
</tr>
<tr>
<td headers="h201"><code>jdk.tls.client.SignatureSchemes</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Contains a comma-separated list of supported signature scheme names that
specifies the signature schemes that could be used for TLS connections on
the client side. </td>
<td headers="h203">None</td>
<td headers="h204">Unrecognized or unsupported signature scheme names specified in the
property are ignored. If this system property is not defined or empty, then
the provider-specific default is used. The names are not case sensitive. For
a list of signature scheme names, see <a href="#signature-schemes">Appendix D: Signature Schemes</a>.</td>
</tr>  
<tr>
<td headers="h201"><code>jdk.tls.ephemeralDHKeySize</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202"><a href="#customizing_dh_keys">Customizing the Size of Ephemeral Diffie-Hellman Keys</a></td>
<td headers="h203">2048 bits</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>jdk.tls.namedGroups</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Customizing the supported named groups for TLS key exchange</td>
<td headers="h203">If this system property is not defined or the value is empty, then
the implementation default groups and preferences will be used.</td>
<td headers="h204">This contains a comma-separated list within quotation marks of
enabled named groups in preference order. For example:
<code>jdk.tls.namedGroups="secp521r1,secp256r1,ffdhe2048"</code></td>
</tr>
<tr>
<td headers="h201"><code>jdk.tls.server.cipherSuites</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Server-side default enabled cipher suites. See
<a href="#default-enabled-cipher-suites">Specifying Default Enabled Cipher Suites</a></td>
<td headers="h203">See <a href="../SunProviders.html#SupportedCipherSuites">SunJSSE Cipher Suites</a>
to determine which cipher suites are
enabled by default </td>
<td headers="h204"><strong>Caution</strong>: These system properties can be used to configure weak
cipher suites, or the configured cipher suites may be weak in the
future. It is not recommended that you use these system properties
without understanding the risks. </td>
</tr>

<tr>
  <td headers="h201"><code>jdk.tls.server.disableExtensions</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
  <td headers="h202"><a href="#ConfiguringDefaultExtensions">Configuring Default Extensions</a></td>
  <td headers="h203">None</td>
  <td headers="h204">Blocks extensions used on the server side.</td>
</tr>

<tr>
<td headers="h201"><code>jdk.tls.server.protocols</code><a href="#jsse-impl-system-property"><sup>1</sup></a> (since JDK 8u261)</td>
<td headers="h202">Default handshaking protocols for TLS servers. See
<a href="../SunProviders.html#SunJSSEProvider">The SunJSSE Provider</a>.</td>
<td headers="h203">None</td>
<td headers="h204">To configure the default enabled protocol suite in the server side
of a <code>SunJSSE</code> provider, specify the protocols in a comma-separated list
within quotation marks. The protocols in this list are standard SSL
protocol names as described in
<a href="../StandardNames.html">Java Security Standard Algorithms</a>.
Note that this system property impacts only the default protocol suite
(SSLContext of the algorithms SSL and TLS). If an application
uses a version-specific <code>SSLContext</code> (SSLv3, TLSv1, TLSv1.1, TLSv1.2, 
or TLSv1.3), or sets the enabled protocol version
explicitly, this system property has no impact.</td>
</tr>
<tr>
<td headers="h201"><code>jdk.tls.server.SignatureSchemes</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Contains a comma-separated list of supported signature scheme names that
specifies the signature schemes that could be used for TLS connections on
the server side.</td>
<td headers="h203">None</td>
<td headers="h204">Unrecognized or unsupported signature scheme names specified in the
property are ignored. If this system property is not defined or empty, then
the provider-specific default is used. The names are not case sensitive. For
a list of signature scheme names, see <a href="#signature-schemes">Appendix D: Signature Schemes</a>.</td>
</tr>   
<tr>
<td headers="h201"><code>jsse.enableFFDHEExtension</code><a href="#jsse-impl-system-property"><sup>1</sup></a> (since JDK 8u261)</td>
<td headers="h202">Enables or disables Finite Field Diffie-Hellman Ephemeral (FFDHE)
parameters for TLS key exchange</td>
<td headers="h203">true</td>
<td headers="h204">FFDHE is a TLS extension defined in RFC 7919. It enables
TLS connections to use known finite field Diffie-Hellman groups.
Some very old TLS vendors may not be able handle TLS extensions. In
this case, set this property to false to disable the FFDHE extension.
</td>
</tr>
<tr>
<td headers="h201"><code>jsse.enableMFLNExtension</code><a href="#jsse-impl-system-property"><sup>1</sup></a> (since JDK 8u261)</td>
<td headers="h202"><a href="#mfln-extension">Customizing Maximum Fragment Length Negotiation (MFLN) Extension</a></td>
<td headers="h203">false</td>
<td headers="h204">None</td>
</tr>
<tr>
<td headers="h201"><code>jsse.enableSNIExtension</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Server Name Indication option</td>
<td headers="h203">true</td>
<td headers="h204">Server Name Indication (SNI) is a TLS extension, defined in RFC
6066. It enables TLS connections to virtual servers, in which multiple
servers for different network names are hosted at a single underlying
network address. Some very old TLS vendors may not be able handle TLS
extensions. In this case, set this property to false to disable the
SNI extension </td>
</tr>
<tr>
<td headers="h201"><code>jsse.SSLEngine.acceptLargeFragments</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202">Default sizing buffers for large TLS packets</td>
<td headers="h203">None</td>
<td headers="h204">Setting this system property to true, <code>SSLSession</code> will size buffers
to handle large data packets by default (see the note in
<a href="#SSLSession">SSLSession and ExtendedSSLSession</a>.
This may cause applications
to allocate unnecessarily large <code>SSLEngine</code> buffers. Instead,
applications should dynamically check for buffer overflow conditions
and resize buffers as appropriate (see
<a href="#OperationStatus">Understanding SSLEngine Operation Statuses</a>).</td>
</tr>
<tr>
<td headers="h201"><code>jdk.tls.client.enableStatusRequestExtension</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202"><a href="ocsp.html#setting-up-a-java-client-to-use-client-driven-ocsp">Setting up a Java Client to use Client-Driven OCSP</a></td>
<td headers="h203">false</td>
<td headers="h204">If true, then the status_request and status_request_v2 extensions
are enabled, and processing for CertificateStatus messages sent by the
server is enabled.</td>
</tr>
<tr>
<td headers="h201"><code>jdk.tls.server.enableStatusRequestExtension</code><a href="#jsse-impl-system-property"><sup>1</sup></a></td>
<td headers="h202"><a href="ocsp.html#setting-up-a-java-server-to-use-ocsp-stapling">Setting Up a Java Server to Use OCSP Stapling</a></td>
<td headers="h203">false</td>
<td headers="h204">If true, then server-side support for OCSP stapling is enabled</td>
</tr>
<tr>
<td headers="h201"><code>sun.security.ssl.allowLegacyHelloMessages</code></td>
<td headers="h202">Allow legacy Hello Messages (Renegotiations)</td>
<td headers="h203">true</td>
<td headers="h204">If true, then allow the peer to handshake without requiring the
proper RFC 5746 messages. See
<a href="tls-renegotiation-issue.html#descPhase2">Description of the Phase 2 Fix</a>
in <a href="tls-renegotiation-issue.html">Transport
Layer Security (TLS) Renegotiation Issue</a> for more information.</td>
</tr>    
<tr>
<td headers="h201"><code>sun.security.ssl.allowUnsafeRenegotiation</code></td>
<td headers="h202">Allow unsafe SSL/TLS renegotiations</td>
<td headers="h203">false</td>
<td headers="h204">If true, then permit full (unsafe) legacy negotiation. See
<a href="tls-renegotiation-issue.html#descPhase2">Description of the Phase 2 Fix</a>
in <a href="tls-renegotiation-issue.html">Transport
Layer Security (TLS) Renegotiation Issue</a> for more information.
</td>
</tr>
</table>

<p><a name="jsse-impl-system-property"><sup>1</sup></a>This system property
is currently used by the JSSE implementation, but it is not guaranteed to
be examined and used by other implementations. If it is examined by
another implementation, then that implementation should handle it in the
same manner as the JSSE implementation does. There is no guarantee the
property will continue to exist or be of the same type (system or
Security) in future releases.</p>

<!-- *********************************************** -->
<h3><a name="SecurityProps" id="SecurityProps">How to Specify a java.security.Security Property</a></h3>
<p>You can customize some aspects of JSSE by setting security
properties. You can set a Security Property either statically or
dynamically:</p>
<ul>
<li>
<p>To set a Security Property statically, add a line to the
Security Properties file. The Security Properties file is located
at <code><em>java-home</em>/lib/security/java.security</code>.</p>
<p><code><em>java-home</em></code> refers to the directory where the JRE is
installed.</p>
<p>To specify a Security Property value in the Security Properties
file, you add a line of the following form:</p>
<pre class="codeblock"><em>propertyName</em>=<em>propertyValue</em></pre>
<p>For example, suppose that you want to specify a different key
manager factory algorithm name than the default SunX509. You do
this by specifying the algorithm name as the value of a security
property named <code>ssl.KeyManagerFactory.algorithm</code>. For
example, to set the value to MyX509, add the following line to the
Security Properties file:</p>
<pre class="codeblock">ssl.KeyManagerFactory.algorithm=MyX509</pre></li>
<li>
<p>To set a Security Property dynamically, call the
<code>java.security.Security.setProperty</code> method in your
code:</p>
<pre class="codeblock">Security.setProperty("<em>propertyName</em>," "<em>propertyValue</em>");</pre>
<p>For example, a call to the <code>setProperty()</code> method
corresponding to the previous example for specifying the key
manager factory algorithm name would be:</p>
<pre class="codeblock">Security.setProperty("ssl.KeyManagerFactory.algorithm", "MyX509");</pre></li>
</ul>


<!-- *********************************************** -->
<h3><a name="how-to-specify-a-java-lang-system-property">How to Specify a java.lang.System Property</a></h3>
<p>You can customize some aspects of JSSE by setting system
properties. There are several ways to set these properties:</p>
<ul>
<li>
<p>To set a system property statically, use the <code>-D</code>
option of the <code>java</code> command. For example, to run an
application named MyApp and set the
<code>javax.net.ssl.trustStore</code> system property to specify a
<a href="#CustomizingStores">truststore</a> named MyCacertsFile,
enter the following:</p>
<pre class="codeblock">java -Djavax.net.ssl.trustStore=MyCacertsFile MyApp</pre></li>
<li>
<p>To set a system property dynamically, call the
<code>java.lang.System.setProperty()</code> method in your
code:</p>
<pre class="codeblock">System.setProperty("<em>propertyName</em>", "<em>propertyValue</em>");</pre>
<p>For example, a <code>setProperty()</code> call corresponding to
the previous example for setting the
<code>javax.net.ssl.trustStore</code> system property to specify a
truststore named "<code>MyCacertsFile</code>" would be:</p>
<pre class="codeblock">System.setProperty("javax.net.ssl.trustStore", "MyCacertsFile");</pre></li>
<li>
<p>In the Java Deployment environment (Plug-In/Web Start), there
are several ways to set the system properties. For more
information, see <a href="../../deploy/index.html">Java Platform,
Standard Edition Deployment Guide</a>.</p>
<ul>
<li>
<p>Use the Java Control Panel to set the Runtime Environment
Property on a local or per-VM basis. This creates a local
<code>deployment.properties</code> file. Deployers can also
distribute an enterprise wide <code>deployment.properties</code>
file by using the <code>deployment.config</code> mechanism. For
more information, see <a href=
"../../deploy/properties.html">Deployment Configuration File and
Properties</a>.</p>
</li>
<li>
<p>To set a property for a specific applet, use the HTML subtag
<code>&lt;PARAM&gt;</code> "java_arguments" within the
<code>&lt;APPLET&gt;</code> tag. For more information, see the
<a href="../../deploy/applet_dev_guide.html#JSDPG712">Command-line
Arguments</a> section of the <cite>Java Platform, Standard Edition
Deployment Guide</cite>.</p>
</li>
<li>
<p>To set the property in a specific Java Web Start application or
applet using Java Plug-in, use the JNLP <code>property</code> sub-element
of the <code>resources</code> element. For more information, see
the <a href=
"../../javaws/developersguide/syntax.html#resources">resources
Element</a> section of the <cite>Java Web Start Guide</cite>.</p>
</li>
</ul>
</li>
</ul>
<!-- *********************************************** -->
<h3><a name="enabling-tls-1.3">Enabling TLS 1.3</a></h3>
<p>JDK 8u261 and later includes an implementation of the Transport Layer
Security (TLS) 1.3 specification (RFC 8446).</p>

<p>TLS 1.3 is enabled for the default <code>SSLContext</code> (<code>SSL</code>
or <code>TLS</code>) at the client endpoint.</p>

<h4>TLS 1.3 Not Directly Compatible with Previous Versions</h4>
<p>TLS 1.3 is not directly compatible with previous versions. Although TLS 1.3 can be implemented with a backward-compatibility mode, there are still several compatibility risks to consider when upgrading to TLS 1.3:</p>
<ul>
<li><p>TLS 1.3 uses a half-close policy, while TLS 1.2 and earlier use a
duplex-close policy. For applications that depend on the duplex-close policy,
there may be compatibility issues when upgrading to TLS 1.3.</p>
</li>
<li>
<p>The signature_algorithms_cert extension requires that pre-defined signature
algorithms are used for certificate authentication. In practice, however,
an application may use unsupported signature algorithms.</p>
</li>
<li>
<p>The DSA signature algorithm is not supported in TLS 1.3. If a server is
configured to only use DSA certificates, it cannot negotiate a TLS 1.3 connection.</p>
</li>
<li>
<p>The supported cipher suites for TLS 1.3 are not the same as TLS 1.2 and
earlier. If an application hardcodes cipher suites that are no longer supported,
it may not be able to use TLS 1.3 without modifications to its code, for example TLS_AES_128_GCM_SHA256 (1.3 and later) versus TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
(1.2 and earlier).</p>
</li>
<li>
<p>The TLS 1.3 session resumption and key update behaviors are different from
TLS 1.2 and earlier. The compatibility impact should be minimal, but it could be
a risk if an application depends on the handshake details of the TLS protocols.</p>
</li>
</ul>

<!-- *********************************************** -->
<h3><a name="X509CCust" id="X509CCust">Customizing the X509Certificate Implementation</a></h3>
<p>The X509Certificate implementation returned by the
<code>X509Certificate.getInstance()</code> method is by default the
implementation from the JSSE implementation.</p>
<p>You can optionally cause a different implementation to be
returned. To do so, specify the name (and package) of the other
implementation's class as the value of a <a href=
"#SecurityProps">Security Property</a> named
<code>cert.provider.x509v1</code>. For example, if the class is
called <code>MyX509CertificateImpl</code> and it appears in the
<code>com.cryptox</code> package, then you should add the following
line to the Security Properties file:</p>
<pre class="codeblock">cert.provider.x509v1=com.cryptox.MyX509CertificateImpl</pre>

<!-- *********************************************** -->

<h3><a name="default-enabled-cipher-suites">Specifying Default Enabled Cipher Suites</a></h3>

<p>You can specify the default enabled cipher suites in your
application or with the system properties
<code>jdk.tls.client.cipherSuites</code> and
<code>jdk.tls.server.cipherSuites</code>.</p>

<hr/>
<p><strong>Note</strong>: The actual use of enabled cipher suites is restricted by algorithm constraints.</p>
<hr/>

<p>The set of cipher suites to enable by default is determined by one of the following ways in this order of preference:</p>

<ol>
<li>Explicitly set by application</li>
<li>Specified by system property</li>
<li>Specified by JSSE provider defaults</li>
</ol>

<p>For example, explicitly setting the default enabled cipher suites in your application overrides settings specified in <code>jdk.tls.client.cipherSuites</code> or <code>jdk.tls.server.cipherSuites</code> as well as JSSE provider defaults.</p>

<h4>Explicitly Set by Application</h4>

<p>You can set which cipher suites are enabled with one of the following methods:</p>

<ul>
<li><code>SSLSocket.setEnabledCipherSuites(String[])</code></li>
<li><code>SSLEngine.setEnabledCipherSuites(String[])</code></li>
<li><code>SSLServerSocket.setEnabledCipherSuites(String[])</code></li>
<li><code>SSLParameters(String[] cipherSuites)</code></li>
<li><code>SSLParameters(String[] cipherSuites, String[] protocols)</code></li>
<li><code>SSLParameters.setCipherSuites(String[])</code></li>
<li><code>https.cipherSuites</code> system property for <code>HttpsURLConnection</code></li>
</ul>

<h4>Specified by System Property</h4>

<p>The system property <code>jdk.tls.client.cipherSuites</code>
specifies the default enabled cipher suites on the client side;
<code>jdk.tls.server.cipherSuites</code> specifies those on the
server side.</p>

<p>The syntax of the value of these two system properties is a
comma-separated list of supported cipher suite names.
Unrecognized or unsupported cipher suite names that are specified
in these properties are ignored. See <a href="../StandardNames.html">Java Security Standard Algorithms</a> for
standard JSSE cipher suite names.</p>

<hr/> 
<p><strong>Note</strong>: These system properties are currently supported by Oracle JDK. They are not guaranteed to be supported by other JDK implementations.</p>
<hr/>
<hr/>
<p><strong>Caution</strong>: These system properties can be used to configure weak cipher suites, or the configured cipher suites may be weak in the future. It is not recommended that you use these system properties without understanding the risks.</p>
<hr/>
<h4>Specified by JSSE Provider Defaults</h4>

<p>Each JSSE provider has its own default enabled cipher suites.
See <a href="../SunProviders.html#SunJSSEProvider">The SunJSSE
Provider</a> in <em>Java Cryptography Architecture Oracle
Providers Documentation for JDK 8</em> for the cipher suite names
supported by the <code>SunJSSE</code> provider and which ones that are enabled
by default.</p>

<!-- *********************************************** -->
<h3><a name="HTTPSCust" id="HTTPSCust">Specifying an Alternative HTTPS Protocol Implementation</a></h3>
<p>You can communicate securely with an SSL-enabled web server by
using the HTTPS URL scheme for the <code>java.net.URL</code> class.
The JDK provides a default HTTPS URL implementation.</p>
<p>If you want an alternative HTTPS protocol implementation to be
used, set the <code>java.protocol.handler.pkgs</code> system property to
include the new class name.
This action causes the specified classes to be found and loaded
before the JDK default classes. See the <a href=
"../../../../api/java/net/URL.html"><code>java.net.URL</code></a>
class documentation for details.</p>
<hr />
<p><strong>Note:</strong> In past JSSE releases, you had to set the
<code>java.protocol.handler.pkgs</code> system property during JSSE
installation. This step is no longer required unless you want to
obtain an instance of
<code>com.sun.net.ssl.HttpsURLConnection</code>. For more
information, see <a href="#HttpsURLConnectionEx">Code Using the
HttpsURLConnection Class</a> in the "Troubleshooting" section.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="ProviderCust" id="ProviderCust">Customizing the Provider Implementation</a></h3>
<p>JDK 1.4 and later releases come standard with a JSSE
Cryptographic Service Provider, or <em>provider</em> for short, named
SunJSSE. Providers are essentially packages that implement one or
more engine classes for specific cryptographic algorithms. The JSSE
engine classes are <code>SSLContext</code>,
<code>KeyManagerFactory</code>, and
<code>TrustManagerFactory</code>. For more information about
providers and engine classes, see the <a href=
"../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<hr />
<p><strong>Note:</strong> The transformation strings used when
SunJSSE calls <code>Cipher.getInstance()</code> are
"RSA/ECB/PKCS1Padding", "RC4", "DES/CBC/NoPadding", and
"DESede/CBC/NoPadding". For further information about the
<code>Cipher</code> class and transformation strings see the
<a href="../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<hr />
<p>Before it can be used, a provider must be registered, either
statically or dynamically. You do not need to register the SunJSSE
provider because it is preregistered. If you want to use other
providers, read the following sections to see how to register
them.</p>
<!-- *********************************************** -->
<h3><a name="registering-the-cryptographic-service-provider-statically">Registering the Cryptographic Service Provider Statically</a></h3>
<p>You register a provider statically by adding a line of the
following form to the <a href="#SecurityProps">Security Properties
file</a>:</p>
<pre class="codeblock">security.provider.<em>n</em>=<em>providerClassName</em></pre>
<p>This declares a provider, and specifies its preference order
<code>n</code>. The preference order is the order in which
providers are searched for requested algorithms (when no specific
provider is requested). "1" is the most preferred, followed by "2",
and so on.</p>
<p>The <em>providerClassName</em> is the fully qualified name of the
provider class. You obtain this name from the provider vendor.</p>
<p>The standard security provider and the SunJSSE provider shipped
with JDK 6 are automatically registered for you; the following
lines appear in the <code>java.security</code> Security Properties
file to register the <code>SunJCE</code> security provider with
preference order 5 and the SunJSSE provider with preference order
4:</p>
<pre class="codeblock">
security.provider.1=sun.security.pkcs11.SunPKCS11 \
${java.home}/lib/security/sunpkcs11-solaris.cfg
security.provider.2=sun.security.provider.Sun
security.provider.3=sun.security.rsa.SunRsaSign
security.provider.4=com.sun.net.ssl.internal.ssl.Provider
security.provider.5=com.sun.crypto.provider.SunJCE
security.provider.6=sun.security.jgss.SunProvider
security.provider.7=com.sun.security.sasl.Provider
</pre>
<p>To use another JSSE provider, add a line registering the other
provider, giving it whatever preference order you prefer.</p>
<p>You can have more than one JSSE provider registered at the same
time. The registered providers may include different
implementations for different algorithms for different engine
classes, or they may have support for some or all of the same types
of algorithms and engine classes. When a particular engine class
implementation for a particular algorithm is searched for, if no
specific provider is specified for the search, then the providers
are searched in preference order and the implementation from the
first provider that supplies an implementation for the specified
algorithm is used.</p>
<!-- *********************************************** -->

<h3><a name="registering-the-cryptographic-service-provider-dynamically">Registering the Cryptographic Service Provider Dynamically</a></h3>
<p>Instead of registering a provider statically, you can add the
provider dynamically at runtime by calling the
<code>Security.addProvider()</code> method at the beginning of your
program. For example, to dynamically add a provider whose provider
class name is <code>MyProvider</code> and whose
<code>MyProvider</code> class resides in the <code>com.ABC</code>
package, you would call:</p>
<pre class="codeblock">
Security.addProvider(new com.ABC.MyProvider());
</pre>
<p>The <code>Security.addProvider()</code> method adds the
specified provider to the next available preference position.</p>
<p>This type of registration is not persistent and can only be done
by a program with sufficient permissions.</p>

<!-- *********************************************** -->
<h3><a name="CustomizingStores" id="CustomizingStores">Customizing the Default Keystores and Truststores, Store Types, and Store Passwords</a></h3>
<p>Whenever a default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created (via a call to
<code>SSLSocketFactory.getDefault</code> or
<code>SSLServerSocketFactory.getDefault</code>), and this default
<code>SSLSocketFactory</code> (or
<code>SSLServerSocketFactory</code>) comes from the JSSE reference
implementation, a default <code>SSLContext</code> is associated
with the socket factory. (The default socket factory will come from
the JSSE implementation.)</p>
<p>This default <code>SSLContext</code> is initialized with a
default <code>KeyManager</code> and a default
<code>TrustManager</code>. If a keystore is specified by the
<code>javax.net.ssl.keyStore</code> system
property and an appropriate
<code>javax.net.ssl.keyStorePassword</code> system property, then the
<code>KeyManager</code> created by the default
<code>SSLContext</code> will be a <code>KeyManager</code>
implementation for managing the specified keystore. (The actual
implementation will be as specified in <a href=
"#DefaultKTMCust">Customizing the Default Key and Trust
Managers</a>.) If no such system property is specified, then the
keystore managed by the <code>KeyManager</code> will be a new empty
keystore.</p>
<p>Generally, the peer acting as the server in the handshake will
need a keystore for its KeyManager in order to obtain credentials
for authentication to the client. However, if one of the anonymous
cipher suites is selected, then the server's
<code>KeyManager</code> keystore is not necessary. And, unless the
server requires client authentication, the peer acting as the
client does not need a <code>KeyManager</code> keystore. Thus, in
these situations it may be OK if no
<code>javax.net.ssl.keyStore</code> system property value is
defined.</p>
<p>Similarly, if a truststore is specified by the
<code>javax.net.ssl.trustStore</code> system property, then the
<code>TrustManager</code> created by the default
<code>SSLContext</code> will be a <code>TrustManager</code>
implementation for managing the specified truststore. In this case,
if such a property exists but the file it specifies does not, then
no truststore is used. If no <code>javax.net.ssl.trustStore</code>
property exists, then a default truststore is searched for. If a
truststore named <code><em>java-home</em>/lib/security/jssecacerts</code> is
found, it is used. If not, then a truststore named
<code><em>java-home</em>/lib/security/cacerts</code> is searched for and used
(if it exists). Finally, if
a truststore is still not found, then the truststore managed by the
<code>TrustManager</code> will be a new empty truststore.</p>
<hr />
<p><strong>Note:</strong> The JDK ships with a limited number of
trusted root certificates in the
<code><em>java-home</em>/lib/security/cacerts</code> file. As documented in
<a href="../../../tools/index.html#security">keytool</a> reference
pages, it is your responsibility to maintain (that is, add and
remove) the certificates contained in this file if you use this
file as a truststore.</p>
<p>Depending on the certificate configuration of the servers that
you contact, you may need to add additional root certificates.
Obtain the needed specific root certificates from the appropriate
vendor.</p>
<hr />
<p>If the <code>javax.net.ssl.keyStoreType</code> and/or
<code>javax.net.ssl.keyStorePassword</code> system properties are
also specified, then they are treated as the default
<code>KeyManager</code> keystore type and password, respectively.
If no type is specified, then the default type is that returned by
the <code>KeyStore.getDefaultType()</code> method, which is the
value of the <code>keystore.type</code> Security Property, or "jks"
if no such Security Property is specified. If no keystore password
is specified, then it is assumed to be a blank string "".</p>
<p>Similarly, if the <code>javax.net.ssl.trustStoreType</code>
and/or <code>javax.net.ssl.trustStorePassword</code> system
properties are also specified, then they are treated as the default
truststore type and password, respectively. If no type is
specified, then the default type is that returned by the
<code>KeyStore.getDefaultType()</code> method. If no truststore
password is specified, then it is assumed to be a blank string
"".</p>
<hr />
<p><strong>Note:</strong> This section describes the current JSSE
reference implementation behavior. The system properties described
in this section are not guaranteed to continue to have the same
names and types (system or security) or even to exist at all in
future releases. They are also not guaranteed to be examined and
used by any other JSSE implementations. If they <em>are</em> examined
by an implementation, then that implementation should handle them
in the same manner as the JSSE reference implementation does, as
described herein.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="DefaultKTMCust" id="DefaultKTMCust">Customizing the Default Key Managers and Trust Managers</a></h3>
<p>As noted in <a href="#CustomizingStores">Customizing the Default
Keystores and Truststores, Store Types, and Store Passwords</a>,
whenever a default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created, and this default
<code>SSLSocketFactory</code> (or
<code>SSLServerSocketFactory</code>) comes from the JSSE reference
implementation, a default <code>SSLContext</code> is associated
with the socket factory.</p>
<p>This default <code>SSLContext</code> is initialized with a
<code>KeyManager</code> and a <code>TrustManager</code>. The
<code>KeyManager</code> and/or <code>TrustManager</code> supplied
to the default <code>SSLContext</code> will be an implementation
for managing the specified keystore or truststore, as described in
the aforementioned section.</p>
<p>The <code>KeyManager</code> implementation chosen is determined
by first examining the <code>ssl.KeyManagerFactory.algorithm</code>
<a href="#SecurityProps">Security Property</a>. If such a property
value is specified, then a <code>KeyManagerFactory</code>
implementation for the specified algorithm is searched for. The
implementation from the first provider that supplies an
implementation is used. Its <code>getKeyManagers()</code> method is
called to determine the <code>KeyManager</code> to supply to the
default <code>SSLContext</code>. Technically,
<code>getKeyManagers()</code> returns an array of
<code>KeyManager</code> objects, one <code>KeyManager</code> for
each type of key material. If no such Security Property value is
specified, then the default value of SunX509 is used to perform the
search.</p>
<hr />
<p><strong>Note:</strong> A <code>KeyManagerFactory</code>
implementation for the SunX509 algorithm is supplied by the SunJSSE
provider. The <code>KeyManager</code> that it specifies is a
<code>javax.net.ssl.X509KeyManager</code> implementation.</p>
<hr />
<p>Similarly, the <code>TrustManager</code> implementation chosen
is determined by first examining the
<code>ssl.TrustManagerFactory.algorithm</code> Security Property.
If such a property value is specified, then a
<code>TrustManagerFactory</code> implementation for the specified
algorithm is searched for. The implementation from the first
provider that supplies an implementation is used. Its
<code>getTrustManagers()</code> method is called to determine the
<code>TrustManager</code> to supply to the default
<code>SSLContext</code>. Technically,
<code>getTrustManagers()</code> returns an array of
<code>TrustManager</code> objects, one <code>TrustManager</code>
for each type of trust material. If no such Security Property value
is specified, then the default value of PKIX is used to perform the
search.</p>
<hr />
<p><strong>Note:</strong> A <code>TrustManagerFactory</code>
implementation for the PKIX algorithm is supplied by the SunJSSE
provider. The <code>TrustManager</code> that it specifies is a
<code>javax.net.ssl.X509TrustManager</code> implementation.</p>
<hr />
<hr />
<p><strong>Note:</strong> This section describes the current JSSE
reference implementation behavior. The system properties described
in this section are not guaranteed to continue to have the same
names and types (system or security) or even to exist at all in
future releases. They are also not guaranteed to be examined and
used by any other JSSE implementations. If they <em>are</em> examined
by an implementation, then that implementation should handle them
in the same manner as the JSSE reference implementation does, as
described herein.</p>
<hr />
<!-- *********************************************** -->

<h3><a name="DisabledAlgorithms">Disabled and Restricted Cryptographic Algorithms</a></h3>

<p>In some environments, certain algorithms or key lengths may be undesirable
when using TLS. The Oracle JDK uses the
<code>jdk.certpath.disabledAlgorithms</code> and
<code>jdk.tls.disabledAlgorithm</code> Security Properties to disable algorithms 
during TLS protocol negotiation, including version negotiation, cipher 
suites selection, peer authentication, and key exchange mechanisms. Note that 
these Security Properties are not guaranteed to be used by other JDK 
implementations. See the
<code><em>&lt;java-home&gt;</em>/lib/security/java.security</code> file for
information about the syntax of these Security Properties and their current
active values.</p>

<ul>
<li><p><code>jdk.certpath.disabledAlgorithms</code> Property: CertPath code uses this Security Property to determine 
which algorithms should not be allowed during CertPath checking. For example, 
when a TLS server sends an identifying certificate chain, a client 
TrustManager that uses a CertPath implementation to verify the received chain 
will not allow the stated conditions. For example, the following line blocks 
any MD2-based certificate, as well as SHA1 TLSServer certificates that chain 
to trust anchors that are pre-installed in the cacaerts keystore. Likewise, 
this line blocks any RSA key less than 1024 bits.</p>

<pre>jdk.certpath.disabledAlgorithms=MD2, SHA1 jdkCA &amp; usage TLSServer, RSA keySize &lt; 1024</pre>

</li>

<li><p><code>jdk.tls.disabledAlgorithms</code> Property: SunJSSE code uses this
Security Property to disable TLS 
protocols, cipher suites, keys, and so on. The syntax is similar to the 
<code>jdk.certpath.disabledAlgorithms</code> Security Property. For example, 
the following line disables the SSLv3 algorithm and all of the TLS_*_RC4_* 
cipher suites:</p>

<pre>jdk.tls.disabledAlgorithms=SSLv3, RC4</pre>

</li>
</ul>

<p>If you require a particular condition, you can reactivate it by either
removing the associated value in the Security Property in the
<code>java.security</code> file or dynamically setting the proper Security
Property before JSSE is initialized.</p>

<p>Note that these Security Properties effectively create a third set of cipher 
suites, Disabled. The following list describes these three sets:</p>

<ul>
<li><strong>Disabled</strong>: If a cipher suite contains any components
(for example, RC4) on 
the disabled list (for example, RC4 is specified in the
<code>jdk.tls.disabledAlgorithms</code> Security Property), then that cipher 
suite is disabled and will not be considered for a connection handshake.</li>
<li><strong>Enabled</strong>: A list of specific cipher suites that will be
considered for a connection.</li>
<li><strong>Not Enabled</strong>: A list of non-disabled cipher suites that
will not be considered for a connection. To re-enable these cipher suites,
call the appropriate <code>setEnabledCipherSuites</code> or
<code>setSSLParameters</code> methods.</li>
</ul>

<!-- *********************************************** -->

<h3><a name="LegacyAlgorithms">Legacy Cryptographic Algorithms</a></h3>

<p>In some environments, a certain algorithm may be undesirable but it cannot be
disabled because of its use in legacy applications. Legacy algorithms may still 
be supported, but applications should not use them as the security strength of 
legacy algorithms is usually not strong enough. During TLS security 
parameters negotiation, legacy algorithms are not negotiated unless there are no 
other candidates. The Security Property <code>jdk.tls.legacyAlgorithms</code>
specifies which algorithms the Oracle JDK considers as legacy algorithms. See the
<code><em>&lt;java-home&gt;</em>/lib/security/java.security</code> file for the syntax of
this Security Property.</p>

<hr />

<p><strong>Note:</strong></p>
<ul>
<li>If a legacy algorithm is also restricted through the
<code>jdk.tls.disabledAlgorithms</code> property or the
<code>java.security.AlgorithmConstraints</code> API (see the method
<code><a href="../../../../api/javax/net/ssl/SSLParameters.html#setAlgorithmConstraints-java.security.AlgorithmConstraints-">javax.net.ssl.SSLParameters.setAlgorithmConstraints</a></code>), 
then the algorithm is completely disabled and will not be negotiated.</li>
<li>If your application uses an algorithm specified in the Security Property 
<code>jdk.tls.legacyAlgorithms</code>, use an alternative algorithm as soon as 
possible; a future JDK release may specify a legacy algorithm as a restricted 
algorithm.</li>
</ul>

<hr />
<!-- *********************************************** -->
<h3><a name="JCECust" id="JCECust">Customizing the Encryption Algorithm Providers</a></h3>
<p>The SunJSSE provider uses the SunJCE implementation for all its
cryptographic needs. Although it is recommended that you leave the
provider at its regular position, you can use implementations from
other JCA or JCE providers by registering them <em>before</em> the
SunJCE provider. The <a href=
"../crypto/CryptoSpec.html#ProviderImplReq">standard JCA
mechanism</a> can be used to configure providers, either statically
via the Security Properties file
<code><em>java-home</em>/lib/security/java.security</code>, or dynamically via
the <code>addProvider()</code> or <code>insertProviderAt()</code>
method in the <code>java.security.Security</code> class.</p>

<!-- *********************************************** -->
<h3><a name="customizing_dh_keys" id="customizing_dh_keys">Customizing the Size of Ephemeral Diffie-Hellman Keys</a></h3>

<p>In TLS connections, ephemeral Diffie-Hellman (DH) keys may be used
internally during the handshaking. The SunJSSE provider provides a flexible
approach to customize the strength of the ephemeral DH key size during TLS
handshaking.</p>

<p>Diffie-Hellman (DH) keys of sizes less than 2048 bits have been deprecated
because of their insufficient strength. You can customize the ephemeral DH key
size with the system property <code>jdk.tls.ephemeralDHKeySize</code>. This
system property does not impact DH key sizes in <code>ServerKeyExchange</code>
messages for exportable cipher suites. It impacts only the DHE_RSA, DHE_DSS, and
DH_anon-based cipher suites in the JSSE Oracle provider.</p>

<p>You can specify one of the following values for this property:</p>
<ul>
  <li><p>Undefined: A DH key of size 2048 bits will be used always for
  non-exportable cipher suites. This is the default value for this property.</p></li>

  <li><p><code>legacy</code>: The JSSE Oracle provider preserves the legacy
  behavior (for example, using ephemeral DH keys of sizes 512 bits and 768 bits)
  of JDK 7 and earlier releases.</p></li>
  
  <li><p><code>matched</code>:</p>
    <ul>
      <li><p>For non-exportable anonymous cipher suites, the DH key size in
      <code>ServerKeyExchange</code> messages is 2048 bits.</p>

      <p>For X.509 certificate-based authentication (of non-exportable cipher
      suites), the DH key size matching the corresponding authentication key is
      used, except that a fixed size of 1024 bits is used for any key smaller
      than 1024 bits, and a fixed size of 2048 bits is used for any key larger
      than 2048 bits.</p>

      <p>For example, if the public key size of an authentication certificate is
      2048 bits, then the ephemeral DH key size is 2048 bits unless the cipher
      suite is exportable. This key sizing scheme keeps the cryptographic
      strength consistent between authentication keys and key-exchange keys.</p>
      </li>
    </ul>
  </li>

  <li><p>A valid integer between 1024 and 8192 in multiples of 64, inclusively: A
  fixed ephemeral DH key size of the specified value, in bits, will be used for
  non-exportable cipher suites.</p></li>
</ul>

<p>The following table summarizes the minimum and maximum acceptable DH key
sizes for each of the possible values for the system property
<code>jdk.tls.ephemeralDHKeySize</code>:</p> 

<table border="1" cellspacing="0"
summary="Minimum and maximum acceptable DH key sizes">
<tr>
<th id="h301">Value of <code>jdk.tls.ephemeralDHKeySize</code></th>
<th id="h302">Undefined</th>
<th id="h303"><code>legacy</code></th>
<th id="h304"><code>matched</code></th>
<th id="h305">Integer value (fixed)</th>
</tr>
<tr>
<th id="h306">Exportable DH key size</th>
<td headers="h301">512</td>
<td headers="h302">512</td>
<td headers="h303">512</td>
<td headers="h304">512</td>
</tr>
<tr>
<th id="h307">Non-exportable anonymous cipher suites</th>
<td headers="h301">2048</td>
<td headers="h302">768</td>
<td headers="h303">2048</td>
<td headers="h304">A valid integer between 1024 and 8192 in multiples of 64, inclusively: A
fixed ephemeral DH key size of the specified value, in bits, will be used for
non-exportable cipher suites.</td>
</tr>
<tr>
<th id="h308">Authentication certificate</th>
<td headers="h301">2048</td>
<td headers="h302">768</td>
<td headers="h303">The key size is the same as the authentication certificate unless the key is
less than 1024 bits or greater than 2048 bits. If the key is less than 1024
bits, then a DH key of 1024 bits is used. If the key is greater than 2048 bits,
then a DH key of 2048 bits is used.

<p>Consequently, you may use the values 1024 or 2048 only.</p></td>
<td headers="h304">The fixed key size is specified by a valid integer property value, which
must be between 1024 and 8192 in multiples of 64, inclusively.</td>
</tr>
</table>

<!-- *********************************************** -->

<h3><a name="mfln-extension">Customizing Maximum Fragment Length Negotiation (MFLN) Extension</a></h3>

<p>In order to negotiate smaller maximum fragment lengths, clients have an
option to include an extension of type max_fragment_length in the
ClientHello message. A system property, <code>jsse.enableMFLNExtension</code>,
can be used to enable or disable the MFLN extension for TLS.</p>

<h4>Maximum Fragment Length Negotiation</h4>

<p>It may be desirable for constrained TLS clients to negotiate a
smaller maximum fragment length due to memory limitations or bandwidth
limitations. In order to negotiate smaller maximum fragment lengths,
clients have an option to include an extension of type
max_fragment_length in the (extended) ClientHello message. See RFC 6066.</p>

<p>Once a maximum fragment length has been successfully negotiated, the
TLS client and server can immediately begin fragmenting messages
(including handshake messages) to ensure that no fragment larger than the
negotiated length is sent.</p>

<h4>System Property jsse.enableMFLNExtension</h4>

<p>A system property <code>jsse.enableMFLNExtension</code> is defined to
enable or disable the MFLN extension. The <code>jsse.enableMFLNExtension</code>
is disabled by default.</p>

<p>The value of the system property can be set as follows:</p>

<table border="1" cellspacing="0" summary="List of possible values provided for the 
jsse.enableMFLNExtension system property">
<thead>
<tr>
<th id="h401">System Property</th>
<th id="h402">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h401"><code>jsse.enableMFLNExtension=true</code></td>
<td headers="h402">Enable the MFLN extension. If the returned value of <code>SSLParameters.getMaximumPacketSize()</code>
is less than (2<sup>12</sup> + header-size) the maximum fragment length
negotiation extension would be enabled.</td>
</tr>
<tr>
<td headers="h401"><code>jsse.enableMFLNExtension=false</code></td>
<td headers="h402">Disable the MFLN extension.</td>
</tr>
</tbody>
</table>

<!-- *********************************************** -->

<h3><a name="limit-data-encrypted">Limiting Amount of Data Algorithms May Encrypt with a Set of Keys</a></h3>

<p>You can specify a limit on the amount of data an algorithm may encrypt with
a specific set of keys with the <code>jdk.tls.keyLimits</code> Security
Property. Once this limit is reached, a KeyUpdate post-handshake message is
sent, which requests that the current set of keys be updated. This Security
Property is only for symmetrical ciphers with TLS 1.3.</p>

<p>The syntax for this property is as follows:</p>

<pre class="codeblock">jdk.tls.keyLimits=<em>KeyLimit</em> { , <em>KeyLimit</em> }

<em>KeyLimit</em>:
<em>AlgorithmName</em> <em>KeyUpdate</em> <em>Length</em></pre>

<ul>
<li><code><em>AlgorithmName</em></code>: A full algorithm transformation</li>
<li><code><em>Length</em></code>: The amount of encrypted data in a session before a KeyUpdate message is sent. This value may be an integer value in bytes or as a power of two, for example, 2^37.</li>
</ul>

<p>For example, the following specifies that a KeyUpdate message is sent once the algorithm AES/GCM/NoPadding has encrypted 237 bytes:</p>

<pre class="codeblock">jdk.tls.keyLimits=AES/GCM/NoPadding KeyUpdate 2^37</pre>

<!-- *********************************************** -->

<h3><a name="acknowledge-close-notify-alert">Specifying that close_notify Alert Is Sent When One Is Received</a></h3>

<p>If the <code>jdk.tls.acknowledgeCloseNotify</code> system property is
set to true, then when the client or server receives a close_notify
alert, it sends a corresponding close_notify alert and the connection is
duplex closed.</p>


<p>TLS 1.2 and earlier versions use a duplex-close policy. However, TLS
1.3 uses a half-close policy, which means that the inbound and the
outbound close_notify alerts are independent. When upgrading to TLS 1.3,
unexpected behavior can occur if your application shuts down the
TLS connection by using only one of the <code>SSLEngine.closeInbound()</code>
or <code>SSLEngine.closeOutbound()</code> methods but not both on each
side of the connection. If your application unexpectedly hangs or times
out when the underlying TLS transportation is not duplex closed,
you may need to set this property to true.</p> 


<p>Note that when a TLS connection is no longer needed, the client
and server applications should each close both sides of their respective
connection.</p>

<!-- ******************************** -->

<h2><a name="ConfiguringDefaultExtensions">Configuring Default Extensions</a></h2>

<p>Some TLS implementations may not handle unknown extensions properly. As a result, you might encounter unexpected interoperability issues when the JDK introduces new extensions. Two system properties enable you to customize default extensions:</p>

<ul>
  <li><code>jdk.tls.client.disableExtensions</code>: Blocks extensions used on the client side.</li>
  <li><code>jdk.tls.server.disableExtensions</code>: Blocks extensions used on the server side.</li>
</ul>

<p>If an extension is disabled, then it won't be produced nor processed in handshake messages.</p>

<p>The value of these system properties is a list of comma-separated standard TLS extension names. See <a href="https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml">Transport Layer Security (TLS) Extensions</a> for a list of these names. Extension names are case-sensitive, and unknown, unsupported misspelled and duplicated names are ignored.</p>

<hr/>

<p><strong>Note</strong>: Although system properties exist that enable and disable specific TLS extensions, such as <code>jsse.enableMFLNExtension</code>, <code>jsse.enableSNIExtension</code>, and <code>jsse.enableSNIExtension</code>, an extension won't be enabled if it's disabled through <code>jdk.tls.client.disableExtensions</code> or <code>jdk.tls.server.disableExtensions</code>, even though it could be enabled though the corresponding system property.</p>

<hr/>

<!-- ******************************** -->

<h2><a name="ocsp">Determine X.509 Certificate Revocation Status with OCSP</a></h2>

<p>Use the Online Certificate Status Protocol (OCSP) to determine the
X.509 certificate revocation status during the Transport Layer Security
(TLS) handshake. See <a href="ocsp.html">Client-Driven OCSP and OCSP Stapling</a>.</p>

<!-- ******************************** -->

<!-- *********************************************** -->
<h2><a name="PKCS11" id="PKCS11">Hardware Acceleration and
Smartcard Support</a></h2>
<p>The <a href="../crypto/CryptoSpec.html">Java Cryptography
Architecture (JCA)</a> is a set of packages that provides a
framework and implementations for encryption, key generation and
key agreement, and message authentication code (MAC) algorithms.
The SunJSSE provider uses JCA exclusively for all of its
cryptographic operations and can automatically take advantage of
JCE features and enhancements, including JCA's support for PKCS#11. This
support enables the SunJSSE provider to use hardware cryptographic
accelerators for significant performance improvements and to use
smartcards as keystores for greater flexibility in key and trust
management.</p>
<p>Use of hardware cryptographic accelerators is automatic if JCA
has been configured to use the Oracle PKCS#11 provider, which in
turn has been configured to use the underlying accelerator
hardware. The provider must be configured before any other JCA
providers in the provider list. For details on how to configure the
Oracle PKCS#11 provider, see the <a href="../p11guide.html">PKCS#11
Guide</a>.</p>
<!-- *********************************************** -->
<h3><a name="ConfigSmartcard" id="ConfigSmartcard">Configuring JSSE
to Use Smartcards as Keystores and Truststores</a></h3>
<p>Support for PKCS#11 in JCA also enables access to smartcards as
a keystore. For details on how to configure the type and location
of the keystores to be used by JSSE, see the <a href=
"#InstallationAndCustomization">Customizing JSSE</a> section. To
use a smartcard as a keystore or truststore, set the
<code>javax.net.ssl.keyStoreType</code> and
<code>javax.net.ssl.trustStoreType</code> system properties,
respectively, to <code>pkcs11</code>, and set the
<code>javax.net.ssl.keyStore</code> and
<code>javax.net.ssl.trustStore</code> system properties,
respectively, to <code>NONE</code>. To specify the use of a
specific provider, use the
<code>javax.net.ssl.keyStoreProvider</code> and
<code>javax.net.ssl.trustStoreProvider</code> system properties
(for example, set them to <code>SunPKCS11-joe</code>). By using
these properties, you can configure an application that previously
depended on these properties to access a file-based keystore to use
a smartcard keystore with no changes to the application.</p>
<p>Some applications request the use of keystores programmatically.
These applications can continue to use the existing APIs to
instantiate a <code>Keystore</code> and pass it to its key manager
and trust manager. If the <code>Keystore</code> instance refers to
a PKCS#11 keystore backed by a Smartcard, then the JSSE application
will have access to the keys on the smartcard.</p>
<!-- ********************************** -->
<h3><a name="MultiDynamicKeystores" id=
"MultiDynamicKeystores">Multiple and Dynamic Keystores</a></h3>
<p>smartcards (and other removable tokens) have additional
requirements for an <code>X509KeyManager</code>. Different
smartcards can be present in a smartcard reader during the lifetime
of a Java application, and they can be protected using different
passwords.</p>
<p>The <a href=
"../../../../api/java/security/KeyStore.Builder.html"><code>java.security.KeyStore.Builder</code></a>
class abstracts the construction and initialization of a
<code>KeyStore</code> object. It supports the use of
<code>CallbackHandler</code> for password prompting, and its
subclasses can be used to support additional features as desired by
an application. For example, it is possible to implement a
<code>Builder</code> that allows individual <code>KeyStore</code>
entries to be protected with different passwords. The <a href=
"../../../../api/javax/net/ssl/KeyStoreBuilderParameters.html"><code>
javax.net.ssl.KeyStoreBuilderParameters</code></a> class then can
be used to initialize a KeyManagerFactory using one or more of
these <code>Builder</code> objects.</p>
<p>A <code>X509KeyManager</code> implementation in the SunJSSE
provider called NewSunX509 supports these parameters. If multiple
certificates are available, it attempts to pick a certificate with
the appropriate key usage and prefers valid to expired
certificates.</p>
<p>The following example illustrates how to tell JSSE to use both a
PKCS#11 keystore (which might in turn use a smartcard) and a
PKCS#12 file-based keystore.</p>
<pre class="codeblock">
import javax.net.ssl.*;
import java.security.KeyStore.*;
...

// Specify keystore builder parameters for PKCS#11 keystores
Builder scBuilder = Builder.newInstance("PKCS11", null,
new CallbackHandlerProtection(myGuiCallbackHandler));

// Specify keystore builder parameters for a specific PKCS#12 keystore
Builder fsBuilder = Builder.newInstance("PKCS12", null,
new File(pkcsFileName), new PasswordProtection(pkcsKsPassword));

// Wrap them as key manager parameters
ManagerFactoryParameters ksParams = new KeyStoreBuilderParameters(
Arrays.asList(new Builder[] { scBuilder, fsBuilder }) );

// Create KeyManagerFactory
KeyManagerFactory factory = KeyManagerFactory.getInstance("NewSunX509");

// Pass builder parameters to factory
factory.init(ksParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(factory.getKeyManagers(), null, null);
</pre>
<!-- ********************************** -->
<h2><a name="KRB" id="KRB">Kerberos Cipher Suites</a></h2>
<p>The SunJSSE provider has support for Kerberos cipher suites, as
described in <a href="https://www.ietf.org/rfc/rfc2712.txt">RFC
2712</a>. The following cipher suites are supported but not enabled
by default:</p>
<ul>
<li>TLS_KRB5_WITH_RC4_128_SHA</li>
<li>TLS_KRB5_WITH_RC4_128_MD5</li>
<li>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</li>
<li>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</li>
<li>TLS_KRB5_WITH_DES_CBC_SHA</li>
<li>TLS_KRB5_WITH_DES_CBC_MD5</li>
<li>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</li>
<li>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</li>
<li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</li>
<li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</li>
</ul>
<p>To enable the use of these cipher suites, you must do so
explicitly. For more information, see the API documentation for the
<a href=
"../../../../api/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-">
<code>SSLEngine.setEnabledCipherSuites()</code></a> and <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-">
<code>SSLSocket.setEnabledCipherSuites()</code></a> methods. As
with all other SSL/TLS cipher suites, if a cipher suite is not
supported by the peer, then it will not be selected during cipher
negotiation. Furthermore, if the application and/or server cannot
acquire the necessary Kerberos credentials, then the Kerberos
cipher suites also will not be selected.</p>
<p>The following is an example of a TLS client that will only use
the <code>TLS_KRB5_WITH_DES_CBC_SHA</code> cipher suite:</p>
<pre class="codeblock">
// Create socket
SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslSocket = (SSLSocket) sslsf.createSocket(tlsServer, serverPort);

// Enable only one cipher suite
String enabledSuites[] = { "TLS_KRB5_WITH_DES_CBC_SHA" };
sslSocket.setEnabledCipherSuites(enabledSuites);
</pre>
<!-- ********************************** -->
<h3><a name="KRBRequire" id="KRBRequire">Kerberos
Requirements</a></h3>
<p>You must have the Kerberos infrastructure set up in your
deployment environment before you can use the Kerberos cipher
suites with JSSE. In particular, both the TLS client and server
must have accounts set up with the Kerberos Key Distribution Center
(KDC). At runtime, if one or more of the Kerberos cipher suites
have been enabled, then the TLS client and server will acquire
their Kerberos credentials associated with their respective account
from the KDC. For example, a TLS server running on the machine
<code>mach1.imc.org</code> in the Kerberos realm
<code>IMC.ORG</code> must have an account with the name
<code>host/mach1.imc.org@IMC.ORG</code> and be configured to use
the KDC for <code>IMC.ORG</code>. For information about using
Kerberos with Java SE, see the <a href=
"../jgss/tutorials/KerberosReq.html">Kerberos Requirements</a>
document.</p>
<p>An application can acquire its Kerberos credentials by using the
<a href="../jaas/JAASRefGuide.html">Java Authentication and
Authorization Service (JAAS)</a> and a Kerberos login module. The
JDK comes with a <a href=
"../../../../jre/api/security/jaas/spec/com/sun/security/auth/module/Krb5LoginModule.html">
Kerberos login module</a>. You can use the Kerberos cipher suites
with JSSE with or without JAAS programming, similar to how you can
use the <a href="../jgss/tutorials/index.html">Java Generic
Security Services (Java GSS)</a> with or without JAAS
programming.</p>
<p>To use the Kerberos cipher suites with JSSE without JAAS
programming, you must use the index names
<code>com.sun.net.ssl.server</code> or <code>other</code> for the
TLS server JAAS configuration entry, and
<code>com.sun.net.ssl.client</code> or <code>other</code> for the
TLS client, and set the
<code>javax.security.auth.useSubjectCredsOnly</code> system
property to false. For example, a TLS server that is not using JAAS
programming might have the following JAAS configuration file:</p>
<pre class="codeblock">
com.sun.net.ssl.server {
com.sun.security.auth.module.Krb5LoginModule required
principal="host/mach1.imc.org@IMC.ORG"
useKeyTab=true
keyTab=mach1.keytab
storeKey=true;
};
</pre>
<p>An example of how to use Java GSS and Kerberos without JAAS
programming is described in the <a href=
"../jgss/tutorials/BasicClientServer.html">Java GSS Tutorial</a>.
You can adapt it to use JSSE by replacing Java GSS calls with JSSE
calls.</p>
<p>To use the Kerberos cipher suites with JAAS programming, you can
use any index name because your application is responsible for
creating the JAAS <code>LoginContext</code> using the index name,
and then wrapping the JSSE calls inside of a
<code>Subject.doAs()</code> or
<code>Subject.doAsPrivileged()</code> call. An example of how to
use JAAS with Java GSS and Kerberos is described in the <a href=
"../jgss/tutorials/ClientServer.html">Java GSS Tutorial</a>. You
can adapt it to use JSSE by replacing Java GSS calls with JSSE
calls.</p>
<p>If you have trouble using or configuring the JSSE application to
use Kerberos, see the <a href=
"../jgss/tutorials/Troubleshooting.html">Troubleshooting</a>
section of the Java GSS Tutorial.</p>
<!-- ********************************** -->
<h3><a name="KRBPeerID" id="KRBPeerID">Peer Identity
Information</a></h3>
<p>To determine the identity of the peer of an SSL connection, use
the <code>getPeerPrincipal()</code> method in the following
classes:</p>
<ul>
<li><code>javax.net.ssl.SSLSession</code></li>
<li><code>javax.net.ssl.HttpsURLConnection</code></li>
<li><code>javax.net.HandshakeCompletedEvent</code></li>
</ul>
<p>Similarly, to get the identity that was sent to the peer (to
identify the local entity), use the
<code>getLocalPrincipal()</code> method in these classes. For
X509-based cipher suites, these methods will return an instance of
<code>javax.security.auth.x500.X500Principal</code>; for Kerberos
cipher suites, these methods will return an instance of
<code>javax.security.auth.kerberos.KerberosPrincipal</code>.</p>
<p>JSSE applications use <code>getPeerCertificates()</code> and
similar methods in <code>javax.net.ssl.SSLSession</code>,
<code>javax.net.ssl.HttpsURLConnection</code>, and
<code>javax.net.HandshakeCompletedEvent</code> classes to obtain
information about the peer. When the peer does not have any
certificates, <code>SSLPeerUnverifiedException</code> is
thrown.</p>
<p>If the application must determine only the identity of the peer
or identity sent to the peer, then it should use the
<code>getPeerPrincipal()</code> and
<code>getLocalPrincipal()</code> methods, respectively. It should
use <code>getPeerCertificates()</code> and
<code>getLocalCertificates()</code> methods only if it must examine
the contents of those certificates. Furthermore, the application
must be prepared to handle the case where an authenticated peer
might not have any certificate.</p>
<!-- ********************************** -->
<h3><a name="KRBSM" id="KRBSM">Security Manager</a></h3>
<p>When the security manager has been enabled, in addition to the
<code>SocketPermission</code> needed to communicate with the peer,
a TLS client application that uses the Kerberos cipher suites also
needs the following permission:</p>
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<em>serverPrincipal</em>, "initiate");
</pre>
<p>In the preceding code, <em>serverPrincipal</em> is the Kerberos
principal name of the TLS server that the TLS client will be
communicating with (such as
<code>host/mach1.imc.org@IMC.ORG</code>). A TLS server application
needs the following permission:</p>
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<em>serverPrincipal</em>, "accept");
</pre>
<p>In the preceding code, <em>serverPrincipal</em> is the Kerberos
principal name of the TLS server (such as
<code>host/mach1.imc.org@IMC.ORG</code>). If the server or client
must contact the KDC (for example, if its credentials are not
cached locally), then it also needs the following permission:</p>
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<em>tgtPrincipal</em>, "initiate");
</pre>
In the preceding code, <em>tgtPrincipal</em> is the principal name of
the KDC (such as <code>krbtgt/IMC.ORG@IMC.ORG</code>). 
<!-- ********************************** -->
<h2><a name="KeystoreFormats" id="KeystoreFormats">Additional
Keystore Formats (PKCS12)</a></h2>
<p>The PKCS#12 (Personal
Information Exchange Syntax Standard) specifies a portable
format for storage and/or transport of a user's private keys,
certificates, miscellaneous secrets, and other items. The SunJSSE
provider supplies a complete implementation of the PKCS12
<code>java.security.KeyStore</code> format for reading and writing
PKCS12 files. This format is also supported by other toolkits and
applications for importing and exporting keys and certificates,
such as Netscape/Mozilla, Microsoft's Internet Explorer, and
OpenSSL. For example, these implementations can export client
certificates and keys into a file using the <code>.p12</code> file name
extension.</p>
<p>With the SunJSSE provider, you can access PKCS12 keys through
the <code>KeyStore</code> API with a keystore type of PKCS12. In
addition, you can list the installed keys and associated
certificates by using the <code>keytool</code> command with the
<code>-storetype</code> option set to <code>pkcs12</code>. For more
information about <code>keytool</code>, see <a href=
"../../../tools/index.html#security">Security Tools</a>.</p>

<p><strong>Note</strong>: Unlike the JKS store format, to access a PKCS#12
store, you must supply it with a password.</p>

<!-- ********************************** -->
<h2><a name="SNIExtension" id="SNIExtension">Server Name Indication
(SNI) Extension</a></h2>
<p>The SNI extension is a feature that extends the SSL/TLS
protocols to indicate what server name the client is attempting to
connect to during handshaking. Servers can use server name
indication information to decide if specific <code>SSLSocket</code>
or <code>SSLEngine</code> instances should accept a connection. For
example, when multiple virtual or name-based servers are hosted on
a single underlying network address, the server application can use
SNI information to determine whether this server is the exact
server that the client wants to access. Instances of this class can
be used by a server to verify the acceptable server names of a
particular type, such as host names. For more information, see
section 3 of <a href="https://www.ietf.org/rfc/rfc6066.txt">TLS
Extensions (RFC 6066)</a>.</p>
<p>Developers of client applications can explicitly set the server
name indication using the
<code>SSLParameters.setServerNames(List&lt;SNIServerName&gt;
serverNames)</code> method. The following example illustrates this
functionality:</p>
<pre class="codeblock">

SSLSocketFactory factory = ...
SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
// SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);

SSLParameters params = sslSocket.getSSLParameters();
params.setServerNames(serverNames);
sslSocket.setSSLParameters(params);
// sslEngine.setSSLParameters(params);
</pre>
<p>Developers of server applications can use the
<code>SNIMatcher</code> class to decide how to recognize server
name indication. The following two examples illustrate this
functionality:</p>
<p><b>Example 1</b></p>
<pre class="codeblock">

SSLSocket sslSocket = sslServerSocket.accept();

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslSocket.setSSLParameters(params);
</pre>
<p><b>Example 2</b></p>
<pre class="codeblock">

SSLServerSocket sslServerSocket = ...;

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslServerSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslServerSocket.setSSLParameters(params);

SSLSocket sslSocket = sslServerSocket.accept();
</pre>
<p>The following list provides examples for the behavior of the
<code>SNIMatcher</code> when receiving various server name
indication requests in the ClientHello message:</p>
<ul>
<li>
<p>Matcher configured to <code>www\\.example\\.com</code>:</p>
<ul>
<li>If the requested host name is <code>www.example.com</code>,
then it will be accepted and a confirmation will be sent in the
ServerHello message.</li>
<li>If the requested host name is <code>www.example.org</code>,
then it will be rejected with an <code>unrecognized_name</code>
fatal error.</li>
<li>If there is no requested host name or it is empty, then the
request will be accepted but no confirmation will be sent in the
ServerHello message.</li>
</ul>
</li>
<li>
<p>Matcher configured to <code>www\\.invalid\\.com</code>:</p>
<ul>
<li>If the requested host name is <code>www.example.com</code>,
then it will be rejected with an <code>unrecognized_name</code>
fatal error.</li>
<li>If the requested host name is <code>www.example.org</code>,
then it will be accepted and a confirmation will be sent in the
ServerHello message.</li>
<li>If there is no requested host name or it is empty, then the
request will be accepted but no confirmation will be sent in the
ServerHello message.</li>
</ul>
</li>
<li>
<p>Matcher is not configured:</p>
<p>Any requested host name will be accepted but no confirmation
will be sent in the ServerHello message.</p>
</li>
</ul>
<p>For descriptions of new classes that implement the SNI
extension, see:</p>
<ul>
<li><a href="#StandardConstants">StandardConstants Class</a></li>
<li><a href="#SNIServerName">SNIServerName Class</a></li>
<li><a href="#SNIMatcher">SNIMatcher Class</a></li>
<li><a href="#SNIHostName">SNIHostName Class</a></li>
</ul>
<p>For examples, see <a href="#SNIExamples">Using the Server Name
Indication (SNI) Extension</a>.</p>
<!-- ********************************** -->
<h2><a name="ALPN" id=
"ALPN">TLS Application Layer Protocol Negotiation</a></h2>

<p>In JDK 8u251 and later, Application Layer Protocol Negotiation (ALPN) enables
you to negotiate an application protocol for a TLS connection;
see <a href="alpn.html"> TLS Application Layer Protocol Negotiation</a>.</p>

<!-- ********************************** -->
<h2><a name="Troubleshooting" id=
"Troubleshooting">Troubleshooting</a></h2>
<p>This section contains information for troubleshooting JSSE.
First, it provides some common <a href=
"#InstallProbs">configuration problems</a> and ways to solve them,
and then it describes helpful <a href="#Debug">debugging
utilities</a>.</p>
<!-- ********************************** -->
<h3><a name="InstallProbs" id="InstallProbs">Configuration
Problems</a></h3>
<p>This section describes some common configuration problems that
might arise when you use JSSE.</p>
<!-- ********************************** -->
<h3>CertificateException While Handshaking</h3>
<p><b>Problem:</b> When negotiating an SSL connection, the client
or server throws a <code>CertificateException</code>.</p>
<p><b>Cause 1:</b> This is generally caused by the remote side
sending a certificate that is unknown to the local side.</p>
<p><b>Solution 1:</b> The best way to debug this type of problem is
to turn on debugging (see <a href="#Debug">Debugging Utilities</a>)
and watch as certificates are loaded and when certificates are
received via the network connection. Most likely, the received
certificate is unknown to the trust mechanism because the wrong
trust file was loaded. Refer to the following sections for more
information:</p>
<ul>
<li><a href="#JSSEClasses">JSSE Classes and Interfaces</a></li>
<li><a href="#TrustManager">The TrustManager Interface</a></li>
<li><a href="#KeyManager">The KeyManager Interface</a></li>
</ul>
<p><b>Cause 2:</b> The system clock is not set correctly. In this
case, the perceived time may be outside the validity period on one
of the certificates, and unless the certificate can be replaced
with a valid one from a truststore, the system must assume that the
certificate is invalid, and therefore throw the exception.</p>
<p><b>Solution 2:</b> Correct the system clock time.</p>
<!-- ********** 11.22.05 -->
<h3>java.security.KeyStoreException: TrustedCertEntry Not
Supported</h3>
<p><b>Problem:</b> Attempt to store trusted certificates in PKCS12
keystore throws <code>java.security.KeyStoreException:
TrustedCertEntry not supported.</code></p>
<p><b>Cause:</b> Storing trusted certificates in a PKCS12 keystore
is not supported. PKCS12 is mainly used to deliver private keys
with the associated certificate chains. It does not have any notion
of "trusted" certificates. In terms of interoperability, other
PKCS12 vendors have the same restriction. Browsers such as Mozilla
and Internet Explorer do not accept a PKCS12 file with only trusted
certificates.</p>
<p><b>Solution:</b> Use the JKS keystore for storing trusted
certificates.</p>
<!-- ********** 11.22.05 -->
<h3>Runtime Exception: SSL Service Not Available</h3>
<p><b>Problem:</b> When running a program that uses JSSE, an
exception occurs indicating that an SSL service is not available.
For example, an exception similar to one of the following is
thrown:</p>
<pre class="codeblock">
Exception in thread "main" java.net.SocketException:
no SSL Server Sockets

Exception in thread "main":
SSL implementation not available
</pre>
<p><b>Cause:</b> There was a problem with <code>SSLContext</code>
initialization, for example, due to an incorrect password on a
keystore or a corrupted keystore (a JDK vendor once shipped a
keystore in an unknown format, and that caused this type of
error).</p>
<p><b>Solution:</b> Check initialization parameters. Ensure that
any keystores specified are valid and that the passwords specified
are correct. One way that you can check this is by trying to use
the <a href=
"../../../tools/index.html#security"><code>keytool</code>
command-line utility</a> to examine the keystores and the relevant
contents.</p>
<!-- ********************************** -->
<h3><a name="NoAvailCert" id="NoAvailCert">Runtime Exception: "No
available certificate corresponding to the SSL cipher suites which
are enabled"</a></h3>
<p><b>Problem:</b> When trying to run a simple SSL server program,
the following exception is thrown:</p>
<pre class="codeblock">
Exception in thread "main" javax.net.ssl.SSLException:
No available certificate corresponding to the SSL cipher suites which are enabled...
</pre>
<p><b>Cause:</b> Various cipher suites require certain types of key
material. For example, if an RSA cipher suite is enabled, then an
RSA <code>keyEntry</code> must be available in the keystore. If no
such key is available, then this cipher suite cannot be used. This
exception is thrown if there are no available key entries for all
of the cipher suites enabled.</p>
<p><b>Solution:</b> Create key entries for the various cipher suite
types, or use an anonymous suite. Anonymous cipher suites are
inherently dangerous because they are vulnerable to MITM
(man-in-the-middle) attacks. For more information, see <a href=
"https://www.ietf.org/rfc/rfc2246.txt">RFC 2246</a>.</p>
<p>Refer to the following sections to learn how to pass the correct
keystore and certificates:</p>
<ul>
<li><a href="#JSSEClasses">JSSE Classes and Interfaces</a></li>
<li><a href="#CustomizingStores">Customizing the Default Keystores
and Truststores, Store Types, and Store Passwords</a></li>
<li><a href="#KeystoreFormats">Additional Keystore Formats</a></li>
</ul>
<!-- ********************************** -->
<h3>Runtime Exception: No Cipher Suites in Common</h3>
<p><b>Problem 1:</b> When handshaking, the client and/or server
throw this exception.</p>
<p><b>Cause 1:</b> Both sides of an SSL connection must agree on a
common cipher suite. If the intersection of the client's cipher
suite set with the server's cipher suite set is empty, then you
will see this exception.</p>
<p><b>Solution 1:</b> Configure the enabled cipher suites to
include common cipher suites, and be sure to provide an appropriate
<code>keyEntry</code> for asymmetric cipher suites. Also see
<a href="#NoAvailCert">Runtime Exception: "No available
certificate..."</a> in this section.)</p>
<p><b>Problem 2:</b> When using Netscape Navigator or Microsoft
Internet Explorer to access files on a server that only has
DSA-based certificates, a runtime exception occurs indicating that
there are no cipher suites in common.</p>
<p><b>Cause 2:</b> By default, <code>keyEntries</code> created with
<code>keytool</code> use DSA public keys. If only DSA
<code>keyEntries</code> exist in the keystore, then only DSA-based
cipher suites can be used. By default, Navigator and Internet
Explorer send only RSA-based cipher suites. Because the
intersection of client and server cipher suite sets is empty, this
exception is thrown.</p>
<p><b>Solution 2:</b> To interact with Navigator or Internet
Explorer, you should create certificates that use RSA-based keys.
To do this, specify the <code>-keyalg</code> RSA option when using
keytool. For example:</p>
<pre class="codeblock">
keytool -genkeypair -alias duke -keystore testkeys -keyalg rsa
</pre>
<!-- ********************************** -->
<h3>Slowness of the First JSSE Access</h3>
<p><b>Problem:</b> JSSE seems to stall on first access.</p>
<p><b>Cause:</b> JSSE must have a secure source of random numbers.
The initialization takes a while.</p>
<p><b>Solution:</b> Provide an alternative generator of random
numbers, or initialize ahead of time when the overhead will not be
noticed:</p>
<pre class="codeblock">
SecureRandom sr = new SecureRandom();
sr.nextInt();
SSLContext.init(..., ..., sr);
</pre>
<p>The <code><em>java-home</em>/lib/security/java.security</code> file also
provides a way to specify the source of seed data for
<code>SecureRandom</code>. See the contents of the file for more
information. <!-- ********************************** --></p>
<h3><a name="HttpsURLConnectionEx" id="HttpsURLConnectionEx">Code
Using HttpsURLConnection Class Throws ClassCastException in JSSE
1.0.x</a></h3>
<p><b>Problem:</b> The following code snippet was written using
<code>com.sun.net.ssl.HttpsURLConnection</code> in JSSE 1.0.x:</p>
<pre class="codeblock">
import com.sun.net.ssl.*;
...deleted...
HttpsURLConnection urlc = new URL("https://example.com/").openConnection();
</pre>
<p>When running under JSSE 1.0.x, this code returns a
<code>javax.net.ssl.HttpsURLConnection</code> object and throws a
<code>ClassCastException</code>.</p>
<p><b>Cause:</b> By default, opening an HTTPS URL will create a
<code>javax.net.ssl.HttpsURLConnection</code>.</p>
<p><b>Solution:</b> Previous releases of the JDK (release 6 and
earlier) did not ship with an HTTPS URL implementation. The JSSE
1.0.x implementation did provide such an HTTPS URL handler, and the
installation guide described how to set the URL handler search path
to obtain a JSSE 1.0.x
<code>com.sun.net.ssl.HttpsURLConnection</code> implementation.</p>
<p>In the JDK, there is an HTTPS handler in the default URL handler
search path. It returns an instance of
<code>javax.net.ssl.HttpsURLConnection</code>. By prepending the
old JSSE 1.0.x implementation path to the URL search path via the
<code>java.protocol.handler.pkgs</code> variable, you can still
obtain a <code>com.sun.net.ssl.HttpsURLConnection</code>, and the
code will no longer throw cast exceptions.</p>
See the following examples:
<pre class="codeblock">
% java -Djava.protocol.handler.pkgs=com.sun.net.ssl.internal.www.protocol YourClass
</pre>
<pre class="codeblock">
System.setProperty("java.protocol.handler.pkgs", "com.sun.net.ssl.internal.www.protocol");
</pre>
<!-- ********************************** -->
<h3>Socket Disconnected After Sending ClientHello Message</h3>
<p><b>Problem:</b> A socket attempts to connect, sends a
ClientHello message, and is immediately disconnected.</p>
<p><b>Cause:</b> Some SSL/TLS servers will disconnect if a
ClientHello message is received in a format they do not understand
or with a protocol version number that they do not support.</p>
<p><strong>Solution</strong>: Try adjusting the enabled protocols
on the client side. This involves modifying or invoking some of the
following system properties and methods:</p>
<ul>
<li>System property <a href=
"#https_protocols"><code>https.protocols</code></a> for the
<code><a href=
"../../../../api/javax/net/ssl/HttpsURLConnection.html">HttpsURLConnection</a></code>
class</li>
<li>System property <a href=
"#jdk_tls_client_protocols"><code>jdk.tls.client.protocols</code></a></li>
<li><a href=
"../../../../api/javax/net/ssl/SSLContext.html#getInstance-java.lang.String-">
<code>SSLContext.getInstance</code></a> method</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLEngine.html#setEnabledProtocols-java.lang.String:A-">
<code>SSLEngine.setEnabledProtocols</code></a> method</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-">
<code>SSLSocket.setEnabledProtocols</code></a> method</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-">
<code>SSLParameters.setProtocols</code></a> and <a href=
"../../../../api/javax/net/ssl/SSLEngine.html#setSSLParameters-javax.net.ssl.SSLParameters-">
<code>SSLEngine.setSSLParameters</code></a> methods</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-">
<code>SSLParameters.setProtocols</code></a> and <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setSSLParameters-javax.net.ssl.SSLParameters-">
<code>SSLSocket.setSSLParameters</code></a> methods</li>
</ul>
<!-- <p>Some older server implementations speak only SSLv3 and do not
understand TLS. Ideally, these implementations should negotiate
to SSLv3, but some simply hang up. For backwards compatibility,
some SSL/TLS implementations (such as <code>SunJSSE</code>) can send SSLv3/TLS
ClientHello messages encapsulated in an SSLv2 ClientHello packet.
The SunJSSE provider supports this feature. (See the section <a href="../SunProviders.html#SunJSSE_Protocols">Protocols</a>, which lists the protocols that are enabled by default for the <code>SunJSSE</code> provider.) If you want to use this feature, add the SSLv2Hello protocol to the enabled protocol list, if necessary.</p>
<p>Similarly, some other older server implementations can
speak to TLSv1 but do not understand TLSv1.1 or TLSv1.2. In this situation, consider using a SSL/TLS version fallback scheme:</p> -->
<p>For backwards compatibility, some SSL/TLS implementations (such
as <code>SunJSSE</code>) can send SSL/TLS ClientHello messages encapsulated in
the SSLv2 ClientHello format. The <code>SunJSSE</code> provider supports this
feature. If you want to use this feature, add the "SSLv2Hello"
protocol to the enabled protocol list, if necessary. (Also see the
<a href="../SunProviders.html#SunJSSE_Protocols">Protocols</a>
section, which lists the protocols that are enabled by default for
the <code>SunJSSE</code> provider.)</p>
<p>The SSL/TLS RFC standards require that implementations negotiate
to the latest version both sides speak, but some non-conforming
implementation simply hang up if presented with a version they
don't understand. For example, some older server implementations
that speak only SSLv3 will shutdown if TLSv1.2 is requested. In
this situation, consider using a SSL/TLS version fallback
scheme:</p>
<ol>
<li>Fall back from TLSv1.2 to TLSv1.1 if the server does not
understand TLSv1.2.</li>
<li>Fall back from TLSv1.1 to TLSv1.0 if the previous step does not
work.</li>
</ol>
<p>For example, if the enabled protocol list on the client is
TLSv1, TLSv1.1, and TLSv1.2, a typical SSL/TLS version fallback
scheme may look like:</p>
<ol>
<li>Try to connect to server. If server rejects the SSL/TLS
connection request immediately, go to step 2.</li>
<li>Try the version fallback scheme by removing the highest
protocol version (for example, TLSv1.2 for the first failure) in
the enabled protocol list.</li>
<li>Try to connect to the server again. If server rejects the
connection, go to step 2 unless there is no version to which the
server can fall back.</li>
<li>If the connection fails and SSLv2Hello is not on the enabled
protocol list, restore the enable protocol list and enable
SSLv2Hello. (For example, the enable protocol list should be
SSLv2Hello, SSLv3, TLSv1, TLSv1.1, and TLSv1.2.) Start again from
step 1.</li>
</ol>

<hr/>
<p><strong>Note</strong>: A fallback to a previous version normally
means security strength downgrading to a weaker protocol. It is not
suggested to use a fallback scheme unless it is really necessary,
and you clearly know that the server does not support a higher
protocol version.</p>
<hr/>

<hr/>
<p><strong>Note</strong>: As part of disabling SSLv3, some servers
have also disabled SSLv2Hello, which means communications with
SSLv2Hello-active clients (e.g. JDK 1.5/6) will fail. Starting with
JDK 7, SSLv2Hello default to disabled on clients, enabled on
servers.</p>
<hr/>

<!-- ********************************** -->
<h3>SunJSSE Cannot Find a JCA Provider That Supports a Required
Algorithm and Causes a NoSuchAlgorithmException</h3>
<p><b>Problem:</b> A handshake is attempted and fails when it
cannot find a required algorithm. Examples might include:</p>
<pre class="codeblock">
Exception in thread ...deleted...
...deleted...
Caused by java.security.NoSuchAlgorithmException: Cannot find any
provider supporting RSA/ECB/PKCS1Padding
</pre>
or
<pre class="codeblock">
Caused by java.security.NoSuchAlgorithmException: Cannot find any
provider supporting AES/CBC/NoPadding
</pre>
<p><b>Cause:</b> <code>SunJSSE</code> uses JCE for all its cryptographic
algorithms. By default, the Oracle JDK will use the Standard
Extension ClassLoader to load the SunJCE provider located in
<code><em>java-home</em>/lib/ext/sunjce_provider.jar</code>. If the file
cannot be found or loaded, or if the SunJCE provider has been
deregistered from the <code>Provider</code> mechanism and an
alternative implementation from JCE is not available, then this
exception will be thrown.</p>
<p><b>Solution:</b> Ensure that the SunJCE is available by checking
that the file is loadable and that the provider is registered with
the <code>Provider</code> interface. Try to run the following code
in the context of your SSL connection:</p>
<pre class="codeblock">
import javax.crypto.*;

System.out.println("=====Where did you get AES=====");
Cipher c = Cipher.getInstance("AES/CBC/NoPadding");
System.out.println(c.getProvider());
</pre>
<!-- ********************************** -->
<h3>FailedDownloadException Thrown When Trying to Obtain
Application Resources from Web Server over SSL</h3>
<p><b>Problem:</b> If you receive a
<code>com.sun.deploy.net.FailedDownloadException</code> when trying
to obtain application resources from your web server over SSL, and
your web server uses the virtual host with Server Name Indication
(SNI) extension (such as Apache HTTP Server), then you may have not
configured your web server correctly.</p>
<p><b>Cause:</b> Because Java SE 7 supports the SNI extension in
the JSSE client, the requested host name of the virtual server is
included in the first message sent from the client to the server
during the SSL handshake. The server may deny the client's request
for a connection if the requested host name (the server name
indication) does not match the expected server name, which should
be specified in the virtual host's configuration. This triggers an
SSL handshake unrecognized name alert, which results in a
<code>FailedDownloadException</code> being thrown.</p>
<p><b>Solution:</b> To better diagnose the problem, enable tracing
through the Java Console. See <a href=
"../../deploy/console_trace_log.html">Java Console, Tracing, and
Logging</a> for more information. If the cause of the problem is
<code>javax.net.ssl.SSLProtocolException: handshake alert:
unrecognized_name</code>, it is likely that the virtual host
configuration for SNI is incorrect. If you are using Apache HTTP
Server, see <a href=
"https://httpd.apache.org/docs/trunk/vhosts/name-based.html">Name-based
Virtual Host Support</a> for information about configuring virtual
hosts. In particular, ensure that the <code>ServerName</code>
directive is configured properly in a
<code>&lt;VirtualHost&gt;</code> block.</p>
<p>For more information, see the following:</p>
<ul>
<li><a href=
"https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI">SSL with
Virtual Hosts Using SNI</a> from <a href=
"https://httpd.apache.org/">Apache HTTP Server
Wiki</a></li>
<li><a href=
"https://httpd.apache.org/docs/trunk/ssl/ssl_faq.html">SSL/TLS
Strong Encryption: FAQ</a> from <a href=
"https://httpd.apache.org/docs/">Apache HTTP Server
Documentation</a></li>
<li><a href="https://www.ietf.org/rfc/rfc3546.txt">RFC 3546,
Transport Layer Security (TLS) Extensions</a></li>
<li><a href=
"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=7194590">Bug
7194590: SSL handshaking error caused by virtual server
misconfiguration</a></li>
</ul>
<!-- ********************************** -->
<h3><a name="Debug" id="Debug">Debugging Utilities</a></h3>
<p>JSSE provides dynamic debug tracing support. This is similar to
the support used for debugging access control failures in the Java
SE platform. The generic Java dynamic debug tracing support is
accessed with the <code>java.security.debug</code> system property,
whereas the JSSE-specific dynamic debug tracing support is accessed
with the <code>javax.net.debug</code> system property.</p>
<hr />
<p><strong>Note:</strong> The <code>debug</code> utility is not an
officially supported feature of JSSE.</p>
<hr />
<p>To view the options of the JSSE dynamic debug utility, use the
following command-line option on the <code>java</code> command:</p>
<pre class="codeblock">
-Djavax.net.debug=help
</pre>
<hr />
<p><strong>Note:</strong> If you specify the value
<code>help</code> with either dynamic debug utility when running a
program that does not use any classes that the utility was designed
to debug, you will not get the debugging options.</p>
<hr />
<p>The following complete example shows how to get a list of the
debug options for an application named <code>MyApp</code> that uses
some of the JSSE classes:</p>
<pre class="codeblock">
java -Djavax.net.debug=help MyApp
</pre>
<p>The <code>MyApp</code> application will not run after the debug
help information is printed, as the help code causes the
application to exit.</p>
<p>Current options are:</p>
<ul>
<li><code>all</code>: Turn on all debugging</li>
<li><code>ssl</code>: Turn on SSL debugging</li>
</ul>
<p>The following can be used with the <code>ssl</code> option:</p>
<ul>
<li><code>record</code>: Enable per-record tracing</li>
<li><code>handshake</code>: Print each handshake message</li>
<li><code>keygen</code>: Print key generation data</li>
<li><code>session</code>: Print session activity</li>
<li><code>defaultctx</code>: Print default SSL initialization</li>
<li><code>sslctx</code>: Print <code>SSLContext</code> tracing</li>
<li><code>sessioncache</code>: Print session cache tracing</li>
<li><code>keymanager</code>: Print key manager tracing</li>
<li><code>trustmanager</code>: Print trust manager tracing</li>
</ul>
<p>Messages generated from the <code>handshake</code> option can be
widened with these options:</p>
<ul>
<li><code>data</code>: Hex dump of each handshake message</li>
<li><code>verbose</code>: Verbose handshake message printing</li>
</ul>
<p>Messages generated from the <code>record</code> option can be
widened with these options:</p>
<ul>
<li><code>plaintext</code>: Hex dump of record plaintext</li>
<li><code>packet</code>: Print raw SSL/TLS packets</li>
</ul>
<p>The <code>javax.net.debug</code> property value must be either
<code>all</code> or <code>ssl</code>, optionally followed by debug
specifiers. You can use one or more options. You do <em>not</em> have
to have a separator between options, although a separator such as a
colon (:) or a comma (,) helps readability. It does not matter what
separators you use, and the ordering of the option keywords is also
not important.</p>
<p>For an introduction to reading this debug information, see the
guide, <a href="ReadDebug.html">Debugging SSL/TLS
Connections</a>.</p>
<p>The following are examples of using the
<code>javax.net.debug</code> property:</p>
<ul>
<li>
<p>To view all debugging messages:</p>
<pre class="codeblock">
java -Djavax.net.debug=all MyApp

</pre></li>
<li>
<p>To view the hexadecimal dumps of each handshake message, enter
the following (the colons are optional):</p>
<pre class="codeblock">
java -Djavax.net.debug=ssl:handshake:data MyApp

</pre></li>
<li>
<p>To view the hexadecimal dumps of each handshake message, and to
print trust manager tracing, enter the following (the commas are
optional):</p>
<pre class="codeblock">
java -Djavax.net.debug=SSL,handshake,data,trustmanager MyApp

</pre></li>
</ul>
<!-- ********************************** -->





<!-- ********************************** -->
<h2><a name="CodeExamples" id="CodeExamples">Code Examples</a></h2>
<p>The following code examples are included in this section:</p>
<ul>
<li><a href="#UnsecureSecure">Converting an Unsecure Socket to a
Secure Socket</a>
<ul>
<li><a href="#NoSSLSocket">Socket Example Without SSL</a></li>
<li><a href="#WithSSLSocket">Socket Example With SSL</a></li>
</ul>
</li>
<li><a href="#SampleCode">Running the JSSE Sample Code</a>
<ul>
<li><a href="#SecureConnSample">Sample Code Illustrating a Secure
Socket Connection Between a Client and a Server</a>
<ul>
<li><a href="#SampleConfig">Configuration Requirements</a></li>
<li><a href="#SSC">Running SSLSocketClient</a></li>
<li><a href="#SSCWT">Running SSLSocketClientWithTunneling</a></li>
<li><a href="#SSCWCA">Running
SSLSocketClientWithClientAuth</a></li>
<li><a href="#RunningCFS">Running ClassFileServer</a></li>
<li><a href="#SSCWCAnCFS">Running SSLSocketClientWithClientAuth
with ClassFileServer</a></li>
</ul>
</li>
<li><a href="#HTTPSSample">Sample Code Illustrating HTTPS
Connections</a>
<ul>
<li><a href="#URLReader">Running URLReader</a></li>
<li><a href="#URLReaderWO">Running URLReaderWithOptions</a></li>
</ul>
</li>
<li><a href="#RMISample">Sample Code Illustrating a Secure RMI
Connection</a></li>
<li><a href="#SSLEngineSample">Sample Code Illustrating the Use of
an SSLEngine</a>
<ul>
<li><a href="#RunningSSLEngineSimpleDemo">Running
SSLEngineSimpleDemo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#CreateKeystore">Creating a Keystore to Use with
JSSE</a></li>
<li><a href="#SNIExamples">Using the Server Name Indication (SNI)
Extension</a>
<ul>
<li><a href="#ClientSNIExamples">Typical Client-Side Usage
Examples</a></li>
<li><a href="#ServerSNIExamples">Typical Server-Side Usage
Examples</a></li>
<li><a href="#VirtualSNIExamples">Working with Virtual
Infrastructures</a>
<ul>
<li><a href="#ClientHelloParser">Preparing the ClientHello
Parser</a></li>
<li><a href="#VirtualServerDispSocket">Virtual Server Dispatcher
Based on SSLSocket</a></li>
<li><a href="#VirtualServerDispEngine">Virtual Server Dispatcher
Based on SSLEngine</a></li>
<li><a href="#NoSNI">No SNI Extension Available</a></li>
<li><a href="#FailoverContext">Failover SSLContext</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- ********************************** -->
<h3><a name="UnsecureSecure" id="UnsecureSecure">Converting an
Unsecure Socket to a Secure Socket</a></h3>
<p>This section provides examples of source code that illustrate
how to use JSSE to convert an unsecure socket connection to a
secure socket connection. The code in this section is excerpted
from the book <cite>Java SE 6 Network Security</cite> by Marco
Pistoia, et. al.</p>
<p>First, "Socket Example Without SSL" shows sample code that can
be used to set up communication between a client and a server using
unsecure sockets. This code is then modified in "Socket Example
with SSL" to use JSSE to set up secure socket communication.</p>
<!-- ********************************** -->
<h3><a name="NoSSLSocket" id="NoSSLSocket"></a>Socket Example
Without SSL</h3>
<p>The following examples demonstrates server-side and client-side
code for setting up an unsecure socket connection.</p>
<p>In a Java program that acts as a server and communicates with a
client using sockets, the socket communication is set up with code
similar to the following:</p>
<pre class="codeblock">
import java.io.*;
import java.net.*;

. . .

int port = availablePortNumber;

ServerSocket s;

try {
s = new ServerSocket(port);
Socket c = s.accept();

OutputStream out = c.getOutputStream();
InputStream in = c.getInputStream();

// Send messages to the client through
// the OutputStream
// Receive messages from the client
// through the InputStream
} catch (IOException e) { }
</pre>
<p>The client code to set up communication with a server using
sockets is similar to the following:</p>
<pre class="codeblock">
import java.io.*;
import java.net.*;

. . .

int port = availablePortNumber;
String host = "hostname";

try {
s = new Socket(host, port);

OutputStream out = s.getOutputStream();
InputStream in = s.getInputStream();

// Send messages to the server through
// the OutputStream
// Receive messages from the server
// through the InputStream
} catch (IOException e) { }
</pre>
<!-- ********************************** -->
<h3><a name="WithSSLSocket" id="WithSSLSocket">Socket Example with
SSL</a></h3>
<p>The following examples demonstrate server-side and client-side
code for setting up a secure socket connection.</p>
<p>In a Java program that acts as a server and communicates with a
client using secure sockets, the socket communication is set up
with code similar to the following. Differences between this
program and the one for communication using unsecure sockets are
highlighted in bold.</p>
<pre class="codeblock">
import java.io.*;
import <b>javax.net.ssl.*</b>;

. . .

int port = availablePortNumber;

<b>SSLServerSocket</b> s;

try {
<b>SSLServerSocketFactory sslSrvFact =
(SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
s = (SSLServerSocket)sslSrvFact.createServerSocket(port);</b>

<b>SSLSocket</b> c = <b>(SSLSocket)</b>s.accept();

OutputStream out = c.getOutputStream();
InputStream in = c.getInputStream();

// Send messages to the client through
// the OutputStream
// Receive messages from the client
// through the InputStream
}

catch (IOException e) {
}
</pre>
<p>The client code to set up communication with a server using
secure sockets is similar to the following, where differences with
the unsecure version are highlighted in bold:</p>
<pre class="codeblock">
import java.io.*;
import <b>javax.net.ssl.*</b>;

. . .

int port = availablePortNumber;
String host = "hostname";

try {
<b>SSLSocketFactory sslFact =
(SSLSocketFactory)SSLSocketFactory.getDefault();
SSLSocket s = (SSLSocket)sslFact.createSocket(host, port);</b>

OutputStream out = s.getOutputStream();
InputStream in = s.getInputStream();

// Send messages to the server through
// the OutputStream
// Receive messages from the server
// through the InputStream
}

catch (IOException e) {
}
</pre>
<!-- ********************************** -->
<h3><a name="SampleCode" id="SampleCode">Running the JSSE Sample
Code</a></h3>
<p>The JSSE sample programs illustrate how to use JSSE to:</p>
<ul>
<li><a href="#SecureConnSample">Create a secure socket connection
between a client and a server</a></li>
<li><a href="#HTTPSSample">Create a secure connection to an HTTPS
website</a></li>
<li><a href="#RMISample">Use secure communications with
RMI</a></li>
<li><a href="#SSLEngineSample">Illustrate SSLEngine usage</a></li>
</ul>
<p>When you use the sample code, be aware that the sample programs
are designed to illustrate how to use JSSE. They are not designed
to be robust applications.</p>
<hr />
<p><strong>Note:</strong> Setting up secure communications involves
complex algorithms. The sample programs provide no feedback during
the setup process. When you run the programs, be patient: you may
not see any output for a while. If you run the programs with the
<code>javax.net.debug</code> system property set to
<code>all</code>, you will see more feedback. For an introduction
to reading this debug information, see the guide, <a href=
"ReadDebug.html">Debugging SSL/TLS Connections</a>.</p>
<hr />
<!-- ********************************** -->
<h3><a name="SamplesLoc" id="SamplesLoc">Where to Find the Sample
Code</a></h3>
<p>Most of the sample code is located in the <a href=
"samples/index.html">samples subdirectory</a> of the same directory
as that containing the document you are reading. Follow that link
to see a listing of all the sample code files and text files. That
page also provides a link to a ZIP file that you can download to
obtain all the sample code files, which is helpful if you are
viewing this documentation from the web.</p>
<p>The following sections describe the samples. For more
information, see <a href="samples/README.txt">README.txt</a>.</p>
<!-- ********************************** -->
<h3><a name="SecureConnSample" id="SecureConnSample">Sample Code
Illustrating a Secure Socket Connection Between a Client and a
Server</a></h3>
<p>The sample programs in the <code>samples/sockets</code>
directory illustrate how to set up a secure socket connection
between a client and a server.</p>
<p>When running the sample client programs, you can communicate
with an existing server, such as a commercial web server, or you
can communicate with the sample server program,
<code>ClassFileServer</code>. You can run the sample client and the
sample server programs on different machines connected to the same
network, or you can run them both on one machine but from different
terminal windows.</p>
<p>All the sample <code>SSLSocketClient*</code> programs in the
samples/sockets/client directory (and <code>URLReader*</code>
programs described in <a href="#HTTPSSample">Sample Code
Illustrating HTTPS Connections</a>) can be run with the
<code>ClassFileServer</code> sample server program. An example of
how to do this is shown in <a href="#SSCWCAnCFS">Running
SSLSocketClientWithClientAuth with ClassFileServer</a>. You can
make similar changes to run <code>URLReader</code>,
<code>SSLSocketClient</code>, or
<code>SSLSocketClientWithTunneling</code> with
<code>ClassFileServer</code>.</p>
<p>If an authentication error occurs during communication between
the client and the server (whether using a web server or
<code>ClassFileServer</code>), it is most likely because the
necessary keys are not in the <a href="#Stores">truststore</a>
(trust key database). For example, the <code>ClassFileServer</code>
uses a keystore called <code>testkeys</code> containing the private
key for <code>localhost</code> as needed during the SSL handshake.
The <code>testkeys</code> keystore is included in the same
samples/sockets/server directory as the
<code>ClassFileServer</code> source. If the client cannot find a
certificate for the corresponding public key of
<code>localhost</code> in the truststore it consults, then an
authentication error will occur. Be sure to use the
<code>samplecacerts</code> truststore (which contains the public
key and certificate of the <code>localhost</code>), as described in
the next section. <!-- ********************************** --></p>
<h3><a name="SampleConfig" id="SampleConfig">Configuration
Requirements</a></h3>
<p>When running the sample programs that create a secure socket
connection between a client and a server, you will need to make the
appropriate certificates file (truststore) available. For both the
client and the server programs, you should use the certificates
file <code>samplecacerts</code> from the <code>samples</code>
directory. Using this certificates file will allow the client to
authenticate the server. The file contains all the common
Certificate Authority (CA) certificates shipped with the JDK (in
the cacerts file), plus a certificate for <code>localhost</code>
needed by the client to authenticate <code>localhost</code> when
communicating with the sample server <code>ClassFileServer</code>.
The <code>ClassFileServer</code> uses a keystore containing the
private key for <code>localhost</code> that corresponds to the
public key in <code>samplecacerts</code>.</p>
<p>To make the <code>samplecacerts</code> file available to both
the client and the server, you can either copy it to the file
<code><em>java-home</em>/lib/security/jssecacerts</code>, rename it to
cacerts, and use it to replace the
<code><em>java-home</em>/lib/security/cacerts</code> file, or add the
following option to the command line when running the
<code>java</code> command for both the client and the server:</p>
<pre class="codeblock">-Djavax.net.ssl.trustStore=<em>path_to_samplecacerts_file</em></pre>

<p>The password for the <code>samplecacerts</code> truststore is
<code>changeit</code>. You can substitute your own certificates in
the samples by using the <code>keytool</code> utility.</p>
<p>If you use a browser, such as Netscape Navigator or Microsoft's
Internet Explorer, to access the sample SSL server provided in the
<code>ClassFileServer</code> example, then a dialog box may pop up
with the message that it does not recognize the certificate. This
is normal because the certificate used with the sample programs is
self-signed and is for testing only. You can accept the certificate
for the current session. After testing the SSL server, you should
exit the browser, which deletes the test certificate from the
browser's namespace.</p>
<p>For client authentication, a separate <code>duke</code>
certificate is available in the appropriate directories. The public
key and certificate is also stored in the
<code>samplecacerts</code> file.</p>
<!-- ********************************** -->
<h3><a name="SSC" id="SSC">Running SSLSocketClient</a></h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClient.java">SSLSocketClient.java</a>
program demonstrates how to create a client that uses an
<code>SSLSocket</code> to send an HTTP request and to get a
response from an HTTPS server. The output of this program is the
HTML source for
<code>https://www.verisign.com/index.html</code>.</p>
<p>You must not be behind a firewall to run this program as
provided. If you run it from behind a firewall, you will get an
<code>UnknownHostException</code> because JSSE cannot find a path
through your firewall to <code>www.verisign.com</code>. To create
an equivalent client that can run from behind a firewall, set up
proxy tunneling as illustrated in the sample program
<code>SSLSocketClientWithTunneling</code>.</p>
<!-- ********************************** -->
<h3><a name="SSCWT" id="SSCWT">Running
SSLSocketClientWithTunneling</a></h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClientWithTunneling.java">SSLSocketClientWithTunneling.java</a>
program illustrates how to do proxy tunneling to access a secure
web server from behind a firewall. To run this program, you must
set the following Java system properties to the appropriate
values:</p>
<pre class="codeblock">
java -Dhttps.proxyHost=<em>webproxy</em>
-Dhttps.proxyPort=<em>ProxyPortNumber</em>
SSLSocketClientWithTunneling
</pre>
<hr />
<p><strong>Note:</strong> Proxy specifications with the
<code>-D</code> options are optional. Replace <em>webproxy</em> with
the name of your proxy host and <em>ProxyPortNumber</em> with the
appropriate port number.</p>
<p>The program will return the HTML source file from
<code>https://www.verisign.com/index.html</code>.</p>
<a name="SSCWCA" id="SSCWCA"></a> 
<!-- ********************************** -->
<h3>Running SSLSocketClientWithClientAuth</h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClientWithClientAuth.java">SSLSocketClientWithClientAuth.java</a>
program shows how to set up a key manager to do client
authentication if required by a server. This program also assumes
that the client is not outside a firewall. You can modify the
program to connect from inside a firewall by following the example
in <code>SSLSocketClientWithTunneling</code>.</p>
<p>To run this program, you must specify three parameters: host,
port, and requested file path. To mirror the previous examples, you
can run this program without client authentication by setting the
host to <code>www.verisign.com</code>, the port to
<code>443</code>, and the requested file path to
<code>https://www.verisign.com/</code>. The output when using these
parameters is the HTML for the website
<code>https://www.verisign.com/</code>.</p>
<p>To run <code>SSLSocketClientWithClientAuth</code> to do client
authentication, you must access a server that requests client
authentication. You can use the sample program
<code>ClassFileServer</code> as this server. This is described in
the following sections.</p>
<!-- ********************************** -->
<h3><a name="RunningCFS" id="RunningCFS">Running
ClassFileServer</a></h3>
<p>The program referred to herein as <code>ClassFileServer</code>
is made up of two files: <a href=
"samples/sockets/server/ClassFileServer.java">ClassFileServer.java</a>
and <a href=
"samples/sockets/server/ClassServer.java">ClassServer.java</a>.</p>
<p>To execute them, run <code>ClassFileServer.class</code>, which
requires the following parameters:</p>
<ul>
<li><code>port</code> can be any available unused port number, for
example, you can use the number <code>2001</code>.</li>
<li><code>docroot</code> indicates the directory on the server that
contains the file you want to retrieve. For example, on Solaris,
you can use /home/<em>userid</em>/ (where <em>userid</em> refers to
your particular UID), whereas on Microsoft Windows systems, you can
use c:\.</li>
<li><code>TLS</code> is an optional parameter that indicates that
the server is to use SSL or TLS.</li>
<li><code>true</code> is an optional parameter that indicates that
client authentication is required. This parameter is only consulted
if the TLS parameter is set.</li>
</ul>

<hr/>
<p><strong>Note:</strong> The <code>TLS</code> and
<code>true</code> parameters are optional. If you omit them,
indicating that an ordinary (not TLS) file server should be used,
without authentication, then nothing happens. This is because one
side (the client) is trying to negotiate with TLS, while the other
(the server) is not, so they cannot communicate.</p>
<hr />

<hr/>
<p><strong>Note:</strong> The server expects GET requests in the
form <code>GET /<em>path_to_file</em></code>.</p>
<hr />
<!-- ********************************** -->
<h3><a name="SSCWCAnCFS" id="SSCWCAnCFS">Running
SSLSocketClientWithClientAuth with ClassFileServer</a></h3>
<p>You can use the sample programs <a href=
"samples/sockets/client/SSLSocketClientWithClientAuth.java">SSLSocketClientWithClientAuth</a>
and <code>ClassFileServer</code> to set up authenticated
communication, where the client and server are authenticated to
each other. You can run both sample programs on different machines
connected to the same network, or you can run them both on one
machine but from different terminal windows or command prompt
windows. To set up both the client and the server, do the
following:</p>
<ol>
<li>Run the program <code>ClassFileServer</code> from one machine
or terminal window, as described in <a href="#RunningCFS">Running
ClassFileServer</a>.</li>
<li>Run the program <code>SSLSocketClientWithClientAuth</code> on
another machine or terminal window.
<code>SSLSocketClientWithClientAuth</code> requires the following
parameters:
<ul>
<li><code>host</code> is the host name of the machine that you are
using to run <code>ClassFileServer</code>.</li>
<li><code>port</code> is the same port that you specified for
<code>ClassFileServer</code>.</li>
<li>
<p><code>requestedfilepath</code> indicates the path to the file
that you want to retrieve from the server. You must give this
parameter as <code>/filepath</code>. Forward slashes are required
in the file path because it is used as part of a GET statement,
which requires forward slashes regardless of what type of operating
system you are running. The statement is formed as follows:</p>
<pre class="codeblock">
"GET " + requestedfilepath + " HTTP/1.0"
</pre></li>
</ul>
</li>
</ol>
<hr />
<p><strong>Note:</strong> You can modify the other
<code>SSLClient*</code> applications' <code>GET</code> commands to
connect to a local machine running
<code>ClassFileServer</code>.</p>
<hr/>

<!-- ********************************** -->
<h3><a name="HTTPSSample" id="HTTPSSample">Sample Code Illustrating
HTTPS Connections</a></h3>
<p>There are two primary APIs for accessing secure communications
through JSSE. One way is through a socket-level API that can be
used for arbitrary secure communications, as illustrated by the
<code>SSLSocketClient</code>,
<code>SSLSocketClientWithTunneling</code>, and
<code>SSLSocketClientWithClientAuth</code> (with and without
<code>ClassFileServer</code>) sample programs.</p>
<p>A second, and often simpler, way is through the standard Java
URL API. You can communicate securely with an SSL-enabled web
server by using the HTTPS URL protocol or scheme using the
<code>java.net.URL</code> class.</p>
<p>Support for HTTPS URL schemes is implemented in many of the
common browsers, which allows access to secured communications
without requiring the socket-level API provided with JSSE.</p>
<p>An example URL is <code>https://www.verisign.com</code>.</p>
<p>The trust and key management for the HTTPS URL implementation is
environment-specific. The JSSE implementation provides an HTTPS URL
implementation. To use a different HTTPS protocol implementation,
set the <code>java.protocol.handler.pkgs</code> system property to the package name. See the
<code>java.net.URL</code> class documentation for details.</p>
<p>The samples that you can download with JSSE include two sample
programs that illustrate how to create an HTTPS connection. Both of
these sample programs (<a href=
"samples/urls/URLReader.java"><code>URLReader.java</code></a> and
<a href=
"samples/urls/URLReaderWithOptions.java"><code>URLReaderWithOptions.java</code></a>)
are in the samples/urls directory.</p>
<!-- ********************************** -->
<h3><a name="URLReader" id="URLReader">Running URLReader</a></h3>
<p>The <a href="samples/urls/URLReader.java">URLReader.java</a>
program illustrates using the URL class to access a secure site.
The output of this program is the HTML source for
<code>https://www.verisign.com/</code>. By default, the HTTPS
protocol implementation included with JSSE is used. To use a
different implementation, set the system property
<code>java.protocol.handler.pkgs</code> value to be the name of the
package containing the implementation.</p>
<p>If you are running the sample code behind a firewall, then you
must set the <code>https.proxyHost</code> and
<code>https.proxyPort</code> system properties. For example, to use
the proxy host "webproxy" on port 8080, you can use the following
options for the <code>java</code> command:</p>
<pre class="codeblock">
-Dhttps.proxyHost=webproxy
-Dhttps.proxyPort=8080
</pre>
<p>Alternatively, you can set the system properties within the
source code with the <code>java.lang.System</code> method
<code>setProperty()</code>. For example, instead of using the
command-line options, you can include the following lines in your
program:</p>
<pre class="codeblock">
System.setProperty("java.protocol.handler.pkgs", "com.ABC.myhttpsprotocol");

System.setProperty("https.proxyHost", "webproxy");

System.setProperty("https.proxyPort", "8080");
</pre>
<!--
<hr />
<p><strong>Note:</strong> When running on Windows 95 or Windows 98, the maximum
number of characters allowed in an MS-DOS prompt may not be enough
to include all the command-line options. If you encounter this
problem, either create a BAT file with the entire command or add
the system properties to the source code and recompile the source
code.</p>
<hr />
-->
<!-- ********************************** -->
<h3><a name="URLReaderWO" id="URLReaderWO">Running
URLReaderWithOptions</a></h3>
<p>The <a href=
"samples/urls/URLReaderWithOptions.java">URLReaderWithOptions.java</a>
program is essentially the same as the URLReader.java program,
except that it allows you to optionally input any or all of the
following system properties as arguments to the program when you
run it:</p>
<ul>
<li><code>java.protocol.handler.pkgs</code></li>
<li><code>https.proxyHost</code></li>
<li><code>https.proxyPort</code></li>
<li><code>https.cipherSuites</code></li>
</ul>
<p>To run <code>URLReaderWithOptions</code>, enter the following
command:</p>
<pre class="codeblock">
java URLReaderWithOptions [-h <em>proxyhost</em> -p <em>proxyport</em>] [-k <em>protocolhandlerpkgs</em>] [-c <em>ciphersarray</em>]
</pre>
<hr />
<p><strong>Note:</strong> Multiple protocol handlers can be
included in the <code>protocolhandlerpkgs</code> argument as a list
with items separated by vertical bars. Multiple SSL cipher suite
names can be included in the <code>ciphersarray</code> argument as
a list with items separated by commas. The possible cipher suite
names are the same as those returned by the
<code>SSLSocket.getSupportedCipherSuites()</code> method. The suite
names are taken from the SSL and TLS protocol specifications.</p>
<p>You need a <code>protocolhandlerpkgs</code> argument only if you
want to use an HTTPS protocol handler implementation other than the
default one provided by Oracle.</p>
<p>If you are running the sample code behind a firewall, then you
must include arguments for the proxy host and the proxy port.
Additionally, you can include a list of cipher suites to
enable.</p>
<p>Here is an example of running <code>URLReaderWithOptions</code>
and specifying the proxy host "webproxy" on port 8080:</p>
<pre class="codeblock">
java URLReaderWithOptions -h webproxy -p 8080
</pre>
<hr/>

<!-- ********************************** -->
<h3><a name="RMISample" id="RMISample">Sample Code Illustrating a
Secure RMI Connection</a></h3>
<p>The sample code in the samples/rmi directory illustrates how to
create a secure Java Remote Method Invocation (RMI) connection. The
sample code is based on an <a href=
"../../rmi/socketfactory/index.html">RMI example</a> that is
basically a "Hello World" example modified to install and use a
custom RMI socket factory.</p>
<p>For more information about Java RMI, see the <a href=
"../../rmi/index.html">Java RMI documentation</a>. This web page
points to Java RMI tutorials and other information about Java
RMI.</p>
<!-- ********************************** -->
<h3><a name="SSLEngineSample" id="SSLEngineSample">Sample Code
Illustrating the Use of an SSLEngine</a></h3>
<p><code>SSLEngine</code> gives application developers flexibility
when choosing I/O and compute strategies. Rather than tie the
SSL/TLS implementation to a specific I/O abstraction (such as
single-threaded <code>SSLSockets</code>), <code>SSLEngine</code>
removes the I/O and compute constraints from the SSL/TLS
implementation.</p>
<p>As mentioned earlier, <code>SSLEngine</code> is an advanced API,
and is not appropriate for casual use. Some introductory sample
code is provided here that helps illustrate its use. The first demo
removes most of the I/O and threading issues, and focuses on many
of the SSLEngine methods. The second demo is a more realistic
example showing how <code>SSLEngine</code> might be combined with
Java NIO to create a rudimentary HTTP/HTTPS server.</p>
<!-- ********************************** -->
<h3><a name="RunningSSLEngineSimpleDemo" id=
"RunningSSLEngineSimpleDemo">Running SSLEngineSimpleDemo</a></h3>
<p>The <a href=
"samples/sslengine/SSLEngineSimpleDemo.java">SSLEngineSimpleDemo</a>
is a very simple application that focuses on the operation of the
<code>SSLEngine</code> while simplifying the I/O and threading
issues. This application creates two <code>SSLEngine</code> objects
that exchange SSL/TLS messages via common <code>ByteBuffer</code>
objects. A single loop serially performs all of the engine
operations and demonstrates how a secure connection is established
(handshaking), how application data is transferred, and how the
engine is closed.</p>
<p>The <code>SSLEngineResult</code> provides a great deal of
information about the current state of the <code>SSLEngine</code>.
This example does not examine all of the states. It simplifies the
I/O and threading issues to the point that this is not a good
example for a production environment; nonetheless, it is useful to
demonstrate the overall function of the <code>SSLEngine</code>.</p>

<!-- ********************************** -->
<h3><a name="CreateKeystore" id="CreateKeystore">Creating a
Keystore to Use with JSSE</a></h3>

<p>This section demonstrates how you can use the
<code>keytool</code> utility to create a simple JKS keystore
suitable for use with JSSE. First you make a <code>keyEntry</code>
(with public and private keys) in the keystore, and then you make a
corresponding <code>trustedCertEntry</code> (public keys only) in a
truststore. For client authentication, you follow a similar process
for the client's certificates.</p>
<hr />
<p><strong>Note:</strong> Storing trust anchors and secret keys in
PKCS12 is supported since JDK 8.</p>
<hr/>

<hr />
<p><strong>Note:</strong> It is beyond the scope of this example to
explain each step in detail. For more information, see the
<code>keytool</code> documentation for <a href=
"../../../tools/unix/keytool.html">Solaris, Linux, or macOS</a>
or <a href="../../../tools/windows/keytool.html">Microsoft
Windows</a>.</p>
<hr/>

<p>User input is shown in bold.</p>
<ol>
<li>
<p>Create a new keystore and self-signed certificate with
corresponding public and private keys.</p>
<pre class="codeblock">
% <b>keytool -genkeypair -alias duke -keyalg RSA -validity 7 -keystore keystore </b>

Enter keystore password:  <b>password</b>
What is your first and last name?
[Unknown]:  <b>Duke</b>
What is the name of your organizational unit?
[Unknown]:  <b>Java Software</b>
What is the name of your organization?
[Unknown]:  <b>Oracle, Inc.</b>
What is the name of your City or Locality?
[Unknown]:  <b>Palo Alto</b>
What is the name of your State or Province?
[Unknown]:  <b>CA</b>
What is the two-letter country code for this unit?
[Unknown]:  <b>US</b>
Is CN=Duke, OU=Java Software, O="Oracle, Inc.",
L=Palo Alto, ST=CA, C=US correct?
[no]:  <b>yes</b>

Enter key password for &lt;duke&gt;
(RETURN if same as keystore password):  <b>&lt;CR&gt;</b>

</pre></li>
<li>
<p>Examine the keystore. Notice that the entry type is
<code>keyEntry</code>, which means that this entry has a private
key associated with it).</p>
<pre class="codeblock">
% <b>keytool -list -v -keystore keystore</b>

Enter keystore password:  <b>password</b>

Keystore type: jks
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: duke
Creation date: Dec 20, 2001
Entry type: keyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.",
L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74

</pre></li>
<li>
<p>Export and examine the self-signed certificate.</p>
<pre class="codeblock">
% <b>keytool -export -alias duke -keystore keystore -rfc -file duke.cer</b>
Enter keystore password:  <b>password</b>
Certificate stored in file &lt;duke.cer&gt;
% <b>cat duke.cer</b>
-----BEGIN CERTIFICATE-----
MIICXjCCAccCBDwircEwDQYJKoZIhvcNAQEEBQAwdjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNB
MRIwEAYDVQQHEwlQYWxvIEFsdG8xHzAdBgNVBAoTFlN1biBNaWNyb3N5c3RlbXMsIEluYy4xFjAU
BgNVBAsTDUphdmEgU29mdHdhcmUxDTALBgNVBAMTBER1a2UwHhcNMDExMjIxMDMzNDI1WhcNMDEx
MjI4MDMzNDI1WjB2MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVBhbG8gQWx0
bzEfMB0GA1UEChMWU3VuIE1pY3Jvc3lzdGVtcywgSW5jLjEWMBQGA1UECxMNSmF2YSBTb2Z0d2Fy
ZTENMAsGA1UEAxMERHVrZTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1loObJzNXsi5aSr8
N4XzDksD6GjTHFeqG9DUFXKEOQetfYXvA8F9uWtz8WInrqskLTNzwXgmNeWkoM7mrPpK6Rf5M3G1
NXtYzvxyi473Gh1h9k7tjJvqSVKO7E1oFkQYeUPYifxmjbSMVirWZgvo2UmA1c76oNK+NhoHJ4qj
eCUCAwEAATANBgkqhkiG9w0BAQQFAAOBgQCRPoQYw9rWWvfLPQuPXowvFmuebsTc28qI7iFWm6BJ
TT/qdmzti7B5MHOt9BeVEft3mMeBU0CS2guaBjDpGlf+zsK/UUi1w9C4mnwGDZzqY/NKKWtLxabZ
5M+4MAKLZ92ePPKGpobM2CPLfM8ap4IgAzCbBKd8+CMp8yFmifze9Q==
-----END CERTIFICATE-----

</pre>
<p>Alternatively, you could generate a Certificate Signing Request
(CSR) with <code>-certreq</code> and send that to a Certificate
Authority (CA) for signing, See the section "Request a Signed Certificate from a
CA" (<a href=
"../../../tools/unix/keytool.html#sthref129">Solaris, Linux, or macOS</a>
or <a href="../../../tools/windows/keytool.html#sthref130">Windows</a>) in
the <code>keytool</code> documentation.</p>
</li>
<li>
<p>Import the certificate into a new truststore.</p>
<pre class="codeblock">
% <b>keytool -import -alias dukecert -file duke.cer -keystore truststore</b>
Enter keystore password:  <b>trustword</b>
Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
Trust this certificate? [no]:  <b>yes</b>
Certificate was added to keystore

</pre></li>
<li>
<p>Examine the truststore. Note that the entry type is
<code>trustedCertEntry</code>, which means that a private key is
not available for this entry. It also means that this file is not
suitable as a keystore of the <code>KeyManager</code>.</p>
<pre class="codeblock">
% <b>keytool -list -v -keystore truststore</b>
Enter keystore password:  <b>trustword</b>

Keystore type: jks
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: dukecert
Creation date: Dec 20, 2001
Entry type: trustedCertEntry

Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
Serial number: 3c22adc1
Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
Certificate fingerprints:
MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74

</pre></li>
<li>
<p>Now run your applications with the appropriate keystores.
Because this example assumes that the default
<code>X509KeyManager</code> and <code>X509TrustManager</code> are
used, you select the keystores using the system properties
described in <a href="#InstallationAndCustomization">Customizing
JSSE</a>.</p>
<pre class="codeblock">
% java -Djavax.net.ssl.keyStore=keystore -Djavax.net.ssl.keyStorePassword=password Server

% java -Djavax.net.ssl.trustStore=truststore -Djavax.net.ssl.trustStorePassword=trustword Client

</pre></li>
</ol>
<hr />
<p><strong>Note:</strong> This example authenticated the server
only. For client authentication, provide a similar keystore for the
client's keys and an appropriate truststore for the server.</p>
<hr />
<!-- ********************************** -->
<h3><a name="SNIExamples" id="SNIExamples">Using the Server Name
Indication (SNI) Extension</a></h3>
<p>This section provides code examples that illustrate how you can
use the <a href="#SNIExtension">Server Name Indication (SNI)</a>
extension for client-side and server-side applications, and how it
can be applied to a virtual infrastructure.</p>
<p>For all examples in this section, to apply the parameters after
you set them, call the <code>setSSLParameters(SSLParameters)</code>
method on the corresponding <code>SSLSocket</code>,
<code>SSLEngine</code>, or <code>SSLServerSocket</code> object.</p>
<!-- ********************************** -->
<h3><a name="ClientSNIExamples" id="ClientSNIExamples">Typical
Client-Side Usage Examples</a></h3>
<p>The following is a list of use cases that require understanding
of the SNI extension for developing a client application:</p>
<ul>
<li>
<p><b>Case 1. The client wants to access
<code>www.example.com</code>.</b></p>
<p>Set the host name explicitly:</p>
<pre class="codeblock">
SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);
sslParameters.setServerNames(serverNames);

</pre>
<p>The client should always specify the host name explicitly.</p>
</li>
<li>
<p><b>Case 2. The client does not want to use SNI because the
server does not support it.</b></p>
<p>Disable SNI with an empty server name list:</p>
<pre class="codeblock">
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
sslParameters.setServerNames(serverNames);

</pre></li>
<li>
<p><b>Case 3. The client wants to access URL
<code>https://www.example.com</code>.</b></p>
<p>Oracle providers will set the host name in the SNI extension by
default, but third-party providers may not support the default
server name indication. To keep your application
provider-independent, always set the host name explicitly.</p>
</li>
<li>
<p><b>Case 4. The client wants to switch a socket from server mode
to client mode.</b></p>
<p>First switch the mode with the following method:
<code>sslSocket.setUseClientMode(true)</code>. Then reset the
server name indication parameters on the socket.</p>
</li>
</ul>
<!-- ********************************** -->
<h3><a name="ServerSNIExamples" id="ServerSNIExamples">Typical
Server-Side Usage Examples</a></h3>
<p>The following is a list of use cases that require understanding
of the SNI extension for developing a server application:</p>
<ul>
<li>
<p><b>Case 1. The server wants to accept all server name indication
types.</b></p>
<p>If you do not have any code dealing with the SNI extension, then
the server ignores all server name indication types.</p>
</li>
<li>
<p><b>Case 2. The server wants to deny all server name indications
of type <code>host_name</code>.</b></p>
<p>Set an invalid server name pattern for
<code>host_name</code>:</p>
<pre class="codeblock">
SNIMatcher matcher = SNIHostName.createSNIMatcher("");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);
sslParameters.setSNIMatchers(matchers);

</pre>
<p>Another way is to create an <code>SNIMatcher</code> subclass
with a <code>matches()</code> method that always returns
<code>false</code>:</p>
<pre class="codeblock">
class DenialSNIMatcher extends SNIMatcher {
DenialSNIMatcher() {
super(StandardConstants.SNI_HOST_NAME);
}

@Override
public boolean matches(SNIServerName serverName) {
return false;
}
}

SNIMatcher matcher = new DenialSNIMatcher();
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);
sslParameters.setSNIMatchers(matchers);

</pre></li>
<li>
<p><b>Case 3. The server wants to accept connections to any host
names in the <code>example.com</code> domain.</b></p>
<p>Set the recognizable server name for <code>host_name</code> as a
pattern that includes all <code>*.example.com</code> addresses:</p>
<pre class="codeblock">
SNIMatcher matcher = SNIHostName.createSNIMatcher("(.*\\.)*example\\.com");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);
sslParameters.setSNIMatchers(matchers);

</pre></li>
<li>
<p><b>Case 4. The server wants to switch a socket from client mode
to server mode.</b></p>
<p>First switch the mode with the following method:
<code>sslSocket.setUseClientMode(false)</code>. Then reset the
server name indication parameters on the socket.</p>
</li>
</ul>
<!-- ********************************** -->
<h3><a name="VirtualSNIExamples" id="VirtualSNIExamples">Working
with Virtual Infrastructures</a></h3>
<p>This section describes how to use the Server Name Indication
(SNI) extension from within a virtual infrastructure. It
illustrates how to create a parser for ClientHello messages from a
socket, provides examples of virtual server dispatchers using
<code>SSLSocket</code> and <code>SSLEngine</code>, describes what
happens when the SNI extension is not available, and demonstrates
how to create a failover <code>SSLContext</code>.</p>
<!-- ********************************** -->
<h4><a name="ClientHelloParser" id="ClientHelloParser">Preparing
the ClientHello Parser</a></h4>
<p>Applications must implement an API to parse the ClientHello
messages from a socket. The following examples illustrate the
<code>SSLCapabilities</code> and <code>SSLExplorer</code> classes
that can perform these functions.</p>
<p><a href=
"samples/sni/SSLCapabilities.java">SSLCapabilities.java</a>
encapsulates the SSL/TLS security capabilities during handshaking
(that is, the list of cipher suites to be accepted in an SSL/TLS
handshake, the record version, the hello version, and the server
name indication). It can be retrieved by exploring the network data
of an SSL/TLS connection via the <code>SSLExplorer.explore()</code>
method.</p>
<p><a href="samples/sni/SSLExplorer.java">SSLExplorer.java</a>
explores the initial ClientHello message from a TLS client, but it
does not initiate handshaking or consume network data. The
<code>SSLExplorer.explore()</code> method parses the ClientHello
message, and retrieves the security parameters into
<code>SSLCapabilities</code>. The method must be called before
handshaking occurs on any TLS connections.</p>
<!-- ********************************** -->
<h4><a name="VirtualServerDispSocket" id=
"VirtualServerDispSocket">Virtual Server Dispatcher Based on
SSLSocket</a></h4>
<p>This section describes the procedure for using a virtual server
dispatcher based on <code>SSLSocket</code>.</p>
<ol>
<li>
<p><b>Register the server name handler.</b></p>
<p>At this step, the application may create different
<code>SSLContext</code> objects for different server name
indications, or link a certain server name indication to a
specified virtual machine or distributed system.</p>
<p>For example, if the server name is <code>www.example.org</code>,
then the registered server name handler may be for a local virtual
hosting web service. The local virtual hosting web service will use
the specified <code>SSLContext</code>. If the server name is
<code>www.example.com</code>, then the registered server name
handler may be for a virtual machine hosting on
<code>10.0.0.36</code>. The handler may map this connection to the
virtual machine.</p>
</li>
<li>
<p><b>Create a <code>ServerSocket</code> and accept the new
connection.</b></p>
<pre class="codeblock">
ServerSocket serverSocket = new ServerSocket(serverPort);
Socket socket = serverSocket.accept();

</pre></li>
<li>
<p><b>Read and buffer bytes from the socket input stream, and then
explore the buffered bytes.</b></p>
<pre class="codeblock">
InputStream ins = socket.getInputStream();

byte[] buffer = new byte[0xFF];
int position = 0;
SSLCapabilities capabilities = null;

// Read the header of TLS record
while (position &lt; SSLExplorer.RECORD_HEADER_SIZE) {
int count = SSLExplorer.RECORD_HEADER_SIZE - position;
int n = ins.read(buffer, position, count);
if (n &lt; 0) {
throw new Exception("unexpected end of stream!");
}
position += n;
}

// Get the required size to explore the SSL capabilities
int recordLength = SSLExplorer.getRequiredSize(buffer, 0, position);
if (buffer.length &lt; recordLength) {
buffer = Arrays.copyOf(buffer, recordLength);
}

while (position &lt; recordLength) {
int count = recordLength - position;
int n = ins.read(buffer, position, count);
if (n &lt; 0) {
throw new Exception("unexpected end of stream!");
}
position += n;
}

// Explore
capabilities = SSLExplorer.explore(buffer, 0, recordLength);
if (capabilities != null) {
System.out.println("Record version: " + capabilities.getRecordVersion());
System.out.println("Hello version: " + capabilities.getHelloVersion());
}

</pre></li>
<li>
<p><b>Get the requested server name from the explored
capabilities.</b></p>
<pre class="codeblock">
List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();

</pre></li>
<li>
<p><b>Look for the registered server name handler for this server
name indication.</b></p>
<p>If the service of the host name is resident in a virtual machine
or another distributed system, then the application must forward
the connection to the destination. The application will need to
read and write the raw internet data, rather then the SSL
application from the socket stream.</p>
<pre class="codeblock">
Socket destinationSocket = new Socket(serverName, 443);

// Forward buffered bytes and network data from the current socket to the <code>destinationSocket</code>.

</pre>
<p>If the service of the host name is resident in the same process,
and the host name service can use the <code>SSLSocket</code>
directly, then the application will need to set the
<code>SSLSocket</code> instance to the server:</p>
<pre class="codeblock">
// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...

SSLSocketFactory serviceSocketFac = serviceContext.getSSLSocketFactory();

// wrap the buffered bytes
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket serviceSocket = (SSLSocket)serviceSocketFac.createSocket(socket, bais, true);

// Now the service can use serviceSocket as usual.

</pre></li>
</ol>
<!-- ********************************** -->
<h4><a name="VirtualServerDispEngine" id=
"VirtualServerDispEngine">Virtual Server Dispatcher Based on
SSLEngine</a></h4>
<p>This section describes the procedure for using a virtual server
dispatcher based on <code>SSLEngine</code>.</p>
<ol>
<li>
<p><b>Register the server name handler.</b></p>
<p>At this step, the application may create different
<code>SSLContext</code> objects for different server name
indications, or link a certain server name indication to a
specified virtual machine or distributed system.</p>
<p>For example, if the server name is <code>www.example.org</code>,
then the registered server name handler may be for a local virtual
hosting web service. The local virtual hosting web service will use
the specified <code>SSLContext</code>. If the server name is
<code>www.example.com</code>, then the registered server name
handler may be for a virtual machine hosting on
<code>10.0.0.36</code>. The handler may map this connection to the
virtual machine.</p>
</li>
<li>
<p><b>Create a <code>ServerSocket</code> or
<code>ServerSocketChannel</code> and accept the new
connection.</b></p>
<pre class="codeblock">
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.bind(...);
...
SocketChannel socketChannel = serverSocketChannel.accept();

</pre></li>
<li>
<p><b>Read and buffer bytes from the socket input stream, and then
explore the buffered bytes.</b></p>
<pre class="codeblock">
ByteBuffer buffer = ByteBuffer.allocate(0xFF);
SSLCapabilities capabilities = null;
while (true) {
// ensure the capacity
if (buffer.remaining() == 0) {
ByteBuffer oldBuffer = buffer;
buffer = ByteBuffer.allocate(buffer.capacity() + 0xFF);
buffer.put(oldBuffer);
}

int n = sc.read(buffer);
if (n &lt; 0) {
throw new Exception("unexpected end of stream!");
}

int position = buffer.position();
buffer.flip();
capabilities = explorer.explore(buffer);
buffer.rewind();
buffer.position(position);
buffer.limit(buffer.capacity());
if (capabilities != null) {
System.out.println("Record version: " +
capabilities.getRecordVersion());
System.out.println("Hello version: " +
capabilities.getHelloVersion());
break;
}
}
buffer.flip();  // reset the buffer position and limitation 

</pre></li>
<li>
<p><b>Get the requested server name from the explored
capabilities.</b></p>
<pre class="codeblock">
List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();

</pre></li>
<li>
<p><b>Look for the registered server name handler for this server
name indication.</b></p>
<p>If the service of the host name is resident in a virtual machine
or another distributed system, then the application must forward
the connection to the destination. The application will need to
read and write the raw internet data, rather then the SSL
application from the socket stream.</p>
<pre class="codeblock">
Socket destinationSocket = new Socket(serverName, 443);

// Forward buffered bytes and network data from the current socket to the <code>destinationSocket</code>.

</pre>
<p>If the service of the host name is resident in the same process,
and the host name service can use the <code>SSLEngine</code>
directly, then the application will simply feed the net data to the
<code>SSLEngine</code> instance:</p>
<pre class="codeblock">
// Get service context from registered handler
// or create the context
SSLContext serviceContext = ...

SSLEngine serviceEngine = serviceContext.createSSLEngine();

// Now the service can use the buffered bytes and other byte buffer as usual.

</pre></li>
</ol>
<!-- ********************************** -->
<h4><a name="NoSNI" id="NoSNI">No SNI Extension Available</a></h4>
<p>If there is no server name indication in a ClientHello message,
then there is no way to select the proper service according to SNI.
For such cases, the application may need to specify a default
service, so that the connection can be delegated to it if there is
no server name indication.</p>
<!-- ********************************** -->
<h4><a name="FailoverContext" id="FailoverContext">Failover
SSLContext</a></h4>
<p>The <code>SSLExplorer.explore()</code> method does not check the
validity of SSL/TLS contents. If the record format does not comply
with SSL/TLS specification, or the <code>explore()</code> method is
invoked after handshaking has started, then the method may throw an
<code>IOException</code> and be unable to produce network data. In
such cases, handle the exception thrown by
<code>SSLExplorer.explore()</code> by using a failover
<code>SSLContext</code>, which is not used to negotiate an SSL/TLS
connection, but to close the connection with the proper alert
message. The following example illustrates a failover
<code>SSLContext</code>. You can find an example of the
<code>DenialSNIMatcher</code> class in Case 2 of the <a href=
"#ServerSNIExamples">Typical Server-Side Usage Examples</a>.</p>
<pre class="codeblock">
byte[] buffer = ...       // buffered network data
boolean failed = true;    // SSLExplorer.explore() throws an exception

SSLContext context = SSLContext.getInstance("TLS");
// the failover SSLContext

context.init(null, null, null);
SSLSocketFactory sslsf = context.getSocketFactory();
ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
SSLSocket sslSocket = (SSLSocket)sslsf.createSocket(socket, bais, true);

SNIMatcher matcher = new DenialSNIMatcher();
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);
SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);    // no recognizable server name
sslSocket.setSSLParameters(params);

try {
InputStream sslIS = sslSocket.getInputStream();
sslIS.read();
} catch (Exception e) {
System.out.println("Server exception " + e);
} finally {
sslSocket.close();
}
</pre>
<!-- ********************************** -->
<h2><a name="AppA" id="AppA">Appendix A: Standard Names</a></h2>
<p>The JDK Security API requires and uses a set of standard names
for algorithms, certificates and keystore types. The specification
names previously found here in Appendix A and in the other security
specifications (JCA, CertPath) have been combined in the <a href=
"../StandardNames.html">Standard Names document</a>. Specific
provider information can be found in the <a href=
"../SunProviders.html">Oracle Provider Documentation</a>.</p>
<!-- ********************************** -->
<h2><a name="PLUG" id="PLUG">Appendix B: Provider
Pluggability</a></h2>
<p>JSSE is fully pluggable and does not restrict the use of
third-party JSSE providers in any way.</p>
<!-- ********************************** -->
<h2><a name="tls-renegotiation-issue">Appendix C: TLS Renegotiation Issue</a></h2>
<p>In the fall of 2009, a flaw was discovered in the SSL/TLS
protocols. A fix to the protocol was developed by the IETF TLS
Working Group, and current versions of the JDK contain this fix.
The page <a href="tls-renegotiation-issue.html">Transport Layer Security (TLS) Renegotiation Issue</a> describes the situation in much more detail, along
with interoperability issues when communicating with older
implementations that do not contain this protocol fix</p>
<!-- ********************************** -->
<h2><a name="signature-schemes">Appendix D: Signature Schemes</a></h2>

<p>The following table contains the standard signature scheme names, which are
the algorithms used in the digital signatures of TLS connections and are also
defined in the
<a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-signaturescheme">SignatureScheme section</a>
of the IANA TLS Registry.</p>

<table border="1" cellspacing="0" summary="Signature schemes and their specifications">
<thead>
<tr>
<th id="h501">Signature Scheme</th>
<th id="h502">Specification</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h501">ecdsa_secp256r1_sha256</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">ecdsa_secp384r1_sha384</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">ecdsa_secp521r1_sha512</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">ecdsa_sha1</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">ed25519</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">ed448</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pkcs1_sha1</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pkcs1_sha256</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pkcs1_sha384</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pkcs1_sha512</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pss_pss_sha256</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pss_pss_sha384</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pss_pss_sha512</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pss_rsae_sha256</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pss_rsae_sha384</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
<tr>
<td headers="h501">rsa_pss_rsae_sha512</td>
<td headers="h502"><a href="https://tools.ietf.org/html/rfc8446">RFC 8446</a></td>
</tr>
</tbody>
</table>


<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2024, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
